# OLED

我这里用的是i2c通信来使用OLED了。我的OLED因为是用SSD1306驱动的，所以I2C地址是0x78。如果你的是CH1116，那么I2C地址是0x7A。如果你不知道你OLED的型号是什么，可以用`HAL_I2C_IsDeviceReady`来看看到底哪个地址是可行的。

## 基本辅助函数以及底层变量

```c
#include <string.h>
// OLED器件地址
#define OLED_ADDRESS 0x78

// OLED参数
#define OLED_PAGE 8            // OLED页数
#define OLED_ROW 8 * OLED_PAGE // OLED行数
#define OLED_COLUMN 128        // OLED列数

// 显存
uint8_t OLED_GRAM[OLED_PAGE][OLED_COLUMN];

void OLED_send(uint8_t *data, uint8_t len) {
    HAL_I2C_Master_Transmit(&hi2c1, OLED_ADDRESS, data, len, HAL_MAX_DELAY);
}

void OLED_sendCmd(uint8_t cmd) {
    static uint8_t sendBuffer[2] = {0};
    sendBuffer[1] = cmd;
    OLED_send(sendBuffer, 2);
}

void OLED_clear() {
	memset(OLED_GRAM, 0, sizeof(OLED_GRAM));
}

void OLED_display() {
	static uint8_t sendBuffer[OLED_COLUMN + 1];
	sendBuffer[0] = 0x40;
	for (uint8_t i = 0; i < OLED_PAGE; i++) {
		OLED_sendCmd(0xB0 + i); // 设置页地址
		OLED_sendCmd(0x02);     // 设置列地址低4位
		OLED_sendCmd(0x10);     // 设置列地址高4位
		memcpy(sendBuffer + 1, OLED_GRAM[i], OLED_COLUMN);
		OLED_send(sendBuffer, OLED_COLUMN + 1);
	}
}
```

## 与OLED通信

第一个字节如果是`0x00`则代表这个是一个指令
第一个字节如果是`0x40`则代表这个是一个数据

## 初始化OLED

这个不需要自己修改什么

```c
void OLED_Init() {
    OLED_sendCmd(0xAE); /*关闭显示 display off*/

    OLED_sendCmd(0x02); /*设置列起始地址 set lower column address*/
    OLED_sendCmd(0x10); /*设置列结束地址 set higher column address*/

    OLED_sendCmd(0x40); /*设置起始行 set display start line*/

    OLED_sendCmd(0xB0); /*设置页地址 set page address*/

    OLED_sendCmd(0x81); /*设置对比度 contract control*/
    OLED_sendCmd(0xCF); /*128*/

    OLED_sendCmd(0xA1); /*设置分段重映射 从右到左 set segment remap*/

    OLED_sendCmd(0xA6); /*正向显示 normal / reverse*/

    OLED_sendCmd(0xA8); /*多路复用率 multiplex ratio*/
    OLED_sendCmd(0x3F); /*duty = 1/64*/

    OLED_sendCmd(0xAD); /*设置启动电荷泵 set charge pump enable*/
    OLED_sendCmd(0x8B); /*启动DC-DC */

    OLED_sendCmd(0x33); /*设置泵电压 set VPP 10V */

    OLED_sendCmd(0xC8); /*设置输出扫描方向 COM[N-1]到COM[0] Com scan direction*/

    OLED_sendCmd(0xD3); /*设置显示偏移 set display offset*/
    OLED_sendCmd(0x00); /* 0x00 */

    OLED_sendCmd(0xD5); /*设置内部时钟频率 set osc frequency*/
    OLED_sendCmd(0xC0);

    OLED_sendCmd(0xD9); /*设置放电/预充电时间 set pre-charge period*/
    OLED_sendCmd(0x1F); /*0x22*/

    OLED_sendCmd(0xDA); /*设置引脚布局 set COM pins*/
    OLED_sendCmd(0x12);

    OLED_sendCmd(0xDB); /*设置电平 set vcomh*/
    OLED_sendCmd(0x40);

    OLED_clear();
    OLED_display();

    OLED_sendCmd(0xAF); /*开启显示 display ON*/
}
```

## 打开/关闭OLED

```c
void OLED_on() {
	OLED_sendCmd(0x8D); // 电荷泵使能
	OLED_sendCmd(0x14); // 开启电荷泵
	OLED_sendCmd(0xAF); // 点亮屏幕
}


void OLED_Off() {
	OLED_sendCmd(0x8D); // 电荷泵使能
	OLED_sendCmd(0x10); // 关闭电荷泵
	OLED_sendCmd(0xAE); // 关闭屏幕
}
```

## 两种颜色模式

```c
typedef enum {
  OLED_COLOR_NORMAL = 0, // 正常模式 黑底白字
  OLED_COLOR_REVERSED    // 反色模式 白底黑字
} OLED_ColorMode;

void OLED_setColorMode(OLED_ColorMode mode) {
	if (mode == OLED_COLOR_NORMAL) {
		OLED_sendCmd(0xA6); // 正常显示
	}
	if (mode == OLED_COLOR_REVERSED) {
		OLED_sendCmd(0xA7); // 反色显示
	}
}
```

## 图形化代码（扩展驱动）

### 基本代码
```c
void OLED_drawPixel(uint8_t x, uint8_t y, OLED_ColorMode color) {
	if (x >= OLED_COLUMN || y >= OLED_ROW) return;
	if (!color) {
		OLED_GRAM[y / 8][x] |= 1 << (y % 8);
	} else {
		OLED_GRAM[y / 8][x] &= ~(1 << (y % 8));
	}
}

// 我感觉这个算法实现的不是很好，等我有时间优化一下
void OLED_drawImage(uint8_t x, uint8_t y, uint8_t* data, uint8_t w, uint8_t h, OLED_ColorMode color){
    for (uint8_t i = 0; i < w; i++) {
        for (uint8_t j = 0; j < h; j++) {
            for (uint8_t k = 0; k < 8; k++) {
                if (j * 8 + k >= h) break; // 防止越界(不完整的字节
                OLED_drawPixel(x + i, y + j * 8 + k, !((data[i + j * w] >> k) & 0x01));
            }
        }
    }
}
```

### 基础图形
```c
void OLED_drawLine(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, OLED_ColorMode color) {
  static uint8_t temp = 0;
  if (x1 == x2) {
    if (y1 > y2) {
      temp = y1;
      y1 = y2;
      y2 = temp;
    }
    for (uint8_t y = y1; y <= y2; y++) {
      OLED_setPixel(x1, y, color);
    }
  } else if (y1 == y2) {
    if (x1 > x2) {
      temp = x1;
      x1 = x2;
      x2 = temp;
    }
    for (uint8_t x = x1; x <= x2; x++) {
      OLED_setPixel(x, y1, color);
    }
  } else {
    // Bresenham直线算法
    int16_t dx = x2 - x1;
    int16_t dy = y2 - y1;
    int16_t ux = ((dx > 0) << 1) - 1;
    int16_t uy = ((dy > 0) << 1) - 1;
    int16_t x = x1, y = y1, eps = 0;
    dx = abs(dx);
    dy = abs(dy);
    if (dx > dy) {
      for (x = x1; x != x2; x += ux) {
        OLED_setPixel(x, y, color);
        eps += dy;
        if ((eps << 1) >= dx) {
          y += uy;
          eps -= dx;
        }
      }
    } else {
      for (y = y1; y != y2; y += uy) {
        OLED_setPixel(x, y, color);
        eps += dx;
        if ((eps << 1) >= dy) {
          x += ux;
          eps -= dy;
        }
      }
    }
  }
}


```
