# SPI通信

## 细节版本

当你已经习惯了I2C那套优雅但稍显“拘谨”的电话会议模式后，你可能会遇到一些需要“促膝长谈”、“高速交流”的场景。比如，你需要驱动一块色彩绚丽的TFT液晶屏，需要每秒传输大量的像素数据；或者你需要高速读写一张SD卡，记录海量的传感器日志。这时，I2C的速率可能就有点跟不上节奏了。

此时，你就需要请出通信协议中的“高速车队”——​**​SPI​**​。

如果说I2C是一场所有参会者共用一条发言线的电话会议，那么SPI就是​**​主设备为自己旗下的每个从设备专门铺设了一条“专属电话线”​**​。

这个比喻能帮你理解SPI的核心细节：

- •
    
    ​**​主设备绝对主导​**​：和I2C一样，通信由唯一的主设备（通常是你的Arduino）发起和控制。它掌握着绝对的指挥权。
    
- •
    
    ​**​更多的“专用线路”​**​：SPI不再满足于两根共享线。它至少需要​**​四根线​**​：
    
    1. 1.
        
        ​**​MOSI (Master Out Slave In)​**​：主设备说，从设备听。这是一条​**​专属​**​的数据下发通道。
        
    2. 2.
        
        ​**​MISO (Master In Slave Out)​**​：从设备说，主设备听。这是一条​**​专属​**​的数据上传通道。
        
    3. 3.
        
        ​**​SCK (Serial Clock)​**​：主设备提供的时钟信号，像节拍器一样同步所有人的节奏。
        
    4. 4.
        
        ​**​SS (Slave Select)​**​：​**​最关键的一根线​**​，也叫CS（Chip Select）。这是主设备为​**​每个从设备单独拉的一条“专属呼叫线”​**​。
        
    

这最后一条SS线，是SPI的精髓所在。主设备想要和哪个从设备通信，就把那根对应的SS线电平拉低（就像是按下对应分机的呼叫按钮），说：“嘿，我现在要和你一个人通话了”。其他从设备虽然它们的MOSI和MISO也并联在总线上，但因为自己的SS线没有被选中，就会自动进入“静默”模式，彻底无视总线上的数据交换。

​**​这种“专线专用”的模式带来了哪些显而易见的好处？​**​

1. 1.
    
    ​**​极高的通信速度​**​：这是SPI最显著的优势。因为它不需要像I2C那样在数据中包含地址位、等待应答位，而且通常是​**​全双工​**​的（数据可以同时在MOSI和MISO上双向流动）。它的时钟频率可以轻松达到甚至超过10MHz，比I2C的通常400kHz快了一个数量级还不止。这使它成为驱动彩屏、读写SD卡等需要“吞吐”大量数据任务的绝对首选。
    
2. 2.
    
    ​**​极其简单的数据协议​**​：由于没有了复杂的地址寻址和应答机制，SPI的协议本质上就是“在时钟的节拍下，同步地移位输入和输出数据”。硬件实现起来非常直接高效，软件层面也更容易理解。
    
3. 3.
    
    ​**​无冲突的通信​**​：每个从设备都有自己的SS线，完全由主设备决定谁可以发言。这从根本上避免了I2C总线可能出现的地址冲突等问题，通信非常可靠。
    

​**​当然，天下没有免费的午餐，SPI的代价是什么？​**​

​**​引脚资源​**​。这是SPI最大的“缺点”。每增加一个从设备，你就要为主设备多占用一个宝贵的数字引脚作为SS线。如果你的Arduino Uno想连接3个SPI设备，那么除了共享的MOSI、MISO、SCK三根线外，你还需要额外使用3个数字引脚作为SS线。这对于引脚本就不多的微控制器来说，是一个不小的开销。

​**​在Arduino世界里，SPI是什么样子的？​**​

Arduino通常将引脚10~13预留为SPI接口：

- •
    
    ​**​13 (SCK)​**​：时钟线。
    
- •
    
    ​**​12 (MISO)​**​：主设备输入。
    
- •
    
    ​**​11 (MOSI)​**​：主设备输出。
    
- •
    
    ​**​10 (SS)​**​：默认的从设备选择线（但你完全可以将其定义为任意数字引脚）。
    

和I2C一样，Arduino拥有强大的 `<SPI.h>`库来帮你处理底层操作。而几乎所有常见的SPI设备（如nRF24L01无线模块、以太网控制器W5500、高速ADC芯片等）都有相应的库，让你的代码变得非常简单：

```cpp
#include <SPI.h>  

void setup() {   
	SPI.begin(); // 初始化SPI总线   
	pinMode(10, OUTPUT); // 将引脚10设置为SS，用于控制我们的设备   
	digitalWrite(10, HIGH); // 先拉高SS，不选中设备 
}  
void loop() {   
	digitalWrite(10, LOW); // 拉低SS，选中设备，开始通话   
	SPI.transfer(0x55); // 通过MOSI发送一个字节数据 0x55   
	byte receivedData = SPI.transfer(0x00); // 在发送数据的同时，从MISO接收一个字节  
	digitalWrite(10, HIGH); // 拉高SS，结束通话 
}
```

所以，总结一下：​**​SPI是用“更多的线”换来了“更简单、更高速”的通信​**​。它和I2C、USART一起，构成了Arduino与外界沟通的三大支柱。你的选择策略会非常清晰：

- •
    
    只需要和​**​电脑“对话”​**​或​**​打印调试信息​**​？用​**​USART​**​。
    
- •
    
    要连接​**​多个低速、简单的传感器​**​（如温湿度、气压）？​**​I2C​**​是最优雅、最经济的选择。
    
- •
    
    要驱动​**​高速、数据饥渴型设备​**​（如显示屏、SD卡、高速ADC）？​**​SPI​**​是你的不二之策。
    

理解了它们各自的性格和用途，你就能像一位熟练的指挥官，为你的项目挑选最合适的通信官，让数据在芯片之间高效、可靠地流动起来。

## SPI的一些问题

SPI最大的问题在于它的标准太不严格了，这导致各个设备在实现它的时候都有一些不同，这就意味着当我们在编写接口代码的时候必须仔细阅读设备数据参数。通常来说有编号为0-3的3种传输模式（不是4种么？）这些模式控制数据是在时钟信号的高电平还是低电平传入或传出，以及在高或低电平时时钟无效。
