# 挑战一下今年的卓工题目

![[Pasted image 20250910084520.png]]

## 用到的设备

1. Arduino Uno 开发板
2. DHT11
3. VEML7700
4. BMP280
5. HC-SR501
6. OLED（显示屏）
7. Button（按钮）
8. HC05（蓝牙模块）

## 首先是数据读取

### 温湿度（数字引脚2）

接线：

```cpp
DHT11 |  Arduino
DATA     2
VCC      5v
GND      GND
```

温湿度，用的是**DHT11**，首先安装**DHT sensor library**，这个读取数据很简单：

```cpp
#include <DHT.h>

#define DHTPIN 2      // DHT11 数据引脚连接的数字引脚（例如 D2）
#define DHTTYPE DHT11 // 指定传感器类型

DHT dht(DHTPIN, DHTTYPE); // 初始化 DHT 对象

void setup() {
  Serial.begin(9600); // 启动串口通信
  dht.begin();        // 启动传感器
}

void loop() {
  delay(2000); // 等待 2 秒（DHT11 采样间隔需 ≥1 秒）

  // 读取湿度（单位：%）
  float humidity = dht.readHumidity();
  // 读取温度（单位：摄氏度）
  float temperature = dht.readTemperature();

  // 检查读取是否失败
  if (isnan(humidity) || isnan(temperature)) {
    Serial.println("读取失败，请检查传感器连接！");
    return;
  }

  // 打印结果
  Serial.print("湿度: ");
  Serial.print(humidity);
  Serial.print("%\t");
  Serial.print("温度: ");
  Serial.print(temperature);
  Serial.println("°C");
}
```

#### 参考资料
1. "Arduino如何通过DHT11读取温湿..."点击查看元宝的回答
https://yuanbao.tencent.com/bot/app/share/chat/p27yvBNUzAH3

### 光照值（I2C）

接线：

```cpp
VEML7700    |    Arduino
VCC              5v
GND              GND
SCL              A5
SDA              A4
```

驱动库：​**​Adafruit_VEML7700**

关键读取代码：

```cpp
#include <Wire.h>
#include "Adafruit_VEML7700.h" // 包含Adafruit的VEML7700库

Adafruit_VEML7700 veml = Adafruit_VEML7700(); // 创建传感器对象

void setup() {
  Serial.begin(9600); // 初始化串口通信，用于调试输出

  Wire.begin(); // 初始化I2C通信

  if (!veml.begin()) { // 尝试初始化VEML7700传感器
    Serial.println("无法找到VEML7700传感器，请检查连接！");
    while (1); // 初始化失败，停止程序
  }
  Serial.println("VEML7700传感器初始化成功");

  // 可以进行一些额外的传感器配置，例如：
  // veml.setGain(VEML7700_GAIN_1_8);    // 设置增益
  // veml.setIntegrationTime(VEML7700_IT_100MS); // 设置积分时间
}

void loop() {
  float lux = veml.readLux(); // 读取环境光照度（单位：勒克斯）

  Serial.print("环境光照度: ");
  Serial.print(lux);
  Serial.println(" lx");

  delay(1000); // 每秒读取一次数据
}
```

#### 参考资料

1. "Arduino如何用VEML7700模块..."点击查看元宝的回答
https://yuanbao.tencent.com/bot/app/share/chat/OxvQUh8Webnt

### 气压值（I2C）

接线：

```cpp
BMP280       |     Arduino
VCC                5v
GND                GND
SCL                A5
SDA                A4
```

驱动库：  **​Adafruit BMP280 Library​**​（还要安装依赖库：**Adafruit Unified Sensor​**​）

```cpp
#include <Wire.h>
#include <Adafruit_BMP280.h>

Adafruit_BMP280 bmp; // 使用I2C接口

void setup() {
  Serial.begin(9600);
  while (!Serial); // 等待串口就绪（仅调试需）

  // 初始化传感器（地址0x76或0x77）
  if (!bmp.begin(0x76)) { // 尝试0x76，失败则试0x77
    Serial.println("BMP280未找到！检查接线或地址！");
    while (1); // 停止执行
  }

  // 可选：配置传感器参数
  bmp.setSampling(
    Adafruit_BMP280::MODE_NORMAL,     // 模式（正常/睡眠/强制）
    Adafruit_BMP280::SAMPLING_X2,     // 温度采样
    Adafruit_BMP280::SAMPLING_X16,    // 气压采样
    Adafruit_BMP280::FILTER_X16,      // 滤波
    Adafruit_BMP280::STANDBY_MS_500   // 待机时间
  );
}

void loop() {
  // 读取数据
  float temperature = bmp.readTemperature(); // 摄氏度
  float pressure = bmp.readPressure();       // 帕斯卡(Pa)
  // float altitude = bmp.readAltitude(1013.25); // 计算海拔（输入当前海平面气压）
  float altitude = bmp.readAltitude(1010.0);   // 长沙的平均海平面气压

  // 串口输出
  Serial.print("温度: ");
  Serial.print(temperature);
  Serial.println(" °C");

  Serial.print("气压: ");
  Serial.print(pressure / 100); // 转百帕(hPa)
  Serial.println(" hPa");

  Serial.print("估算海拔: ");
  Serial.print(altitude);
  Serial.println(" 米");
  Serial.println();

  delay(2000); // 2秒更新一次
}
```

#### 小问题

BMP280读取海拔高度，需要知道当前位置的海平面气压。而气压这个东西，又容易受到天气影响，必须要实时获取当前位置的海平面气压才能准确。要获取实时的海平面气压又有点麻烦，所以，我的解决方案是，看最终测出来的海拔是多少，和44.9（长沙的海拔）做对比，使最终的结果相差不到5m就可以了。

不过，这里用的海拔气压是1010.0hPa。反正测不准，我就随便问AI取了一个。

#### 参考资料
1. "Arduino中如何使用BMP280？"点击查看元宝的回答
https://yuanbao.tencent.com/bot/app/share/chat/GAZk2rDYzoPj

### 人体传感（数字引脚4）

模式选择：**可重复触发​**​ (H)：持续检测到移动时保持高电平，直到人离开后才延时关闭

接线：

```cpp
 HC-SR501       |     Arduino
 VCC                  5v
 GND                  GND
 OUT                  4
```

不需要驱动库，直接就可以用了。

```cpp
int sensorPin = 4;  // HC-SR501 的 OUT 引脚连接到的 Arduino 数字引脚
int ledPin = 13;    // LED 连接的引脚（板载LED）

void setup() {
  pinMode(sensorPin, INPUT);   // 设置传感器引脚为输入模式
  pinMode(ledPin, OUTPUT);     // 设置LED引脚为输出模式
  Serial.begin(9600);          // 初始化串口通信，便于调试观察
}

void loop() {
  int motion = digitalRead(sensorPin);  // 读取传感器引脚的状态

  if (motion == HIGH) {          // 如果检测到人体移动
    digitalWrite(ledPin, HIGH);  // 点亮LED
    Serial.println("检测到人体移动！"); // 打印信息到串口监视器
  } else {
    digitalWrite(ledPin, LOW);   // 否则关闭LED
  }
  
  delay(50);  // 短暂的延迟，有助于稳定读取信号
}
```

#### 参考资料

1. "Arduino如何使用HC-SR501"点击查看元宝的回答
https://yuanbao.tencent.com/bot/app/share/chat/BbeeGg6tPoW3

### Conclusion 总结

每一秒读取一次全部数据，因为后面的蓝牙串口通信需要发送全部发送，只是OLED一次性没办法用这么多而已。这里要约定一下变量名，后面要用的

```cpp
float humidity = dht.readHumidity();   // 读取湿度（单位：%）
float temperature = dht.readTemperature();  // 读取温度（单位：摄氏度）
float lux = veml.readLux();   // 读取环境光照度（单位：勒克斯）
float pressure = bmp.readPressure();       // 帕斯卡(Pa)
float altitude = bmp.readAltitude(1013.25); // 计算海拔（输入当前海平面气压）
int motion = digitalRead(sensorPin);     // 前面是否有人 HIGH代表有人 LOW代表没人
```

## 然后是数据发送部分

我打算做三个输出，OLED，蓝牙串口通信，蓝牙Vitepress显示（挂载在github.io上）

### OLED（I2C）（数字引脚7、8）

接线：

```cpp
OLED       |     Arduino
VCC              5v
GND              GND
SCL              A5
SDA              A4
```

最简单的部分，但是，因为OLED屏幕比较小，所以，我打算弄一个分屏显示，就是把三个传感器的数据分开显示。

```cpp
#define NODEVICE_ON 0
#define DHT11_ON 1
#define VEML7700_ON 2
#define BMP280_ON 3

volatile int current_device = NODEVICE_ON
```

如何切换显示设备呢？我打算用两个Button（按钮）实现。这里又需要两个数字引脚了。这边给两个按钮分别命名为A和B了。

接线：

```cpp
Button（两个）    |    Arduino
A.左                  7
B.左                  8
A.右 B.右             GND
```

不需要驱动库，把7、8设置为上拉输入模式，并且加一个中断控制就好了，如下。

```cpp
void moveLeft(){
	current_device--;
	if (current_device < 0) current_device = 3;
}

void moveRight(){
	current_device++;
	if (current_device > 3) current_device = 0;
}

void setup(){
	pinMode(7, INPUT_PULLUP);
	pinMode(8, INPUT_PULLUP);
	attachInterrupt(digitalPinToInterrupt(7), moveLeft, FALLING);
	attachInterrupt(digitalPinToInterrupt(8), moveRight, FALLING);
}
```

然后现在是最关键的编写OLED显示的步骤了，在此之前，请确保你的线连接好了

```cpp
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// OLED 配置参数
#define SCREEN_WIDTH 128 // 屏幕宽度（像素）
#define SCREEN_HEIGHT 64 // 屏幕高度（像素）
#define OLED_ADDR 0x3C   // I2C 地址（根据你的屏幕修改，常见0x3C或0x3D）

// 初始化一个 Adafruit_SSD1306 对象
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

void setup(){
	// 初始化dispaly
	display.begin(SSD1306_SWITCHCAPVCC, OLED_ADDR);
	// 清除显示缓冲区
	display.clearDisplay();
	// 设置文字颜色为白色
	display.setTextColor(SSD1306_WHITE);
	// 刷新OLED
	display.display();
}

void loop(){
	// 当前面有人的时候OLED才开始显示，否则不显示，为了省电嘛
	if (motion == HIGH){
		switch (current_device){
		case NODEVICE_ON:
			display.clearDisplay();
			display.setCursor(0, 0);
			display.setTextSize(1); 
			display.println("MADE BY");
			display.setTextSize(3); 
			display.println("CSUST")
			display.display();
			break;
		case DHT11_ON:
			display.clearDisplay();
			display.setCursor(0, 0);
			display.setTextSize(2); 
			display.println("humidity: ");
			display.println(humidity);
			display.println("temperature: ");
			display.println(temperature);
			display.display();
			break;
		case VEML7700_ON:
			display.clearDisplay();
			display.setCursor(0, 0);
			display.setTextSize(2); 
			display.println("lux: ");
			display.println(lux);
			display.display();
			break;
		case BMP280_ON:
			display.clearDisplay();
			display.setCursor(0, 0);
			display.setTextSize(2); 
			display.println("pres: ");
			display.println(pressure);
			display.println("altitude: ");
			display.println(altitude);
			display.display();
			break;
		default :
			display.clearDisplay();
			display.setCursor(0, 0);
			display.setTextSize(3); 
			display.println("ERROR");
			display.setTextSize(2); 
			display.println("No Device")
			display.display();
			break;
		}
	}
}
```

### 蓝牙串口通信

蓝牙串口通信是最简单的了。

HC05，可以自己调整蓝牙名称和密码，不过这个考试就没必要了。蓝牙串口通信，顾名思义，就是只需要通过USART就可以进行蓝牙通信了。比较简单。

接线：

```cpp
HC05    |    Arduino
VCC          5v
GND          GND
RX           TX
TX           RX
```

然后该怎么串口通信，这里就怎么通信，都是一样的。

```cpp
Serial.print("humidity: ");  // 湿度
Serial.println(humidity);

Serial.print("temperature: ");  // 温度
Serial.println(temperature);

Serial.print("lux: ");    // 光照强度
Serial.println(lux);

Serial.print("pressure: ");    // 气压
Serial.println(pressure);

Serial.print("altitude: ");    // 海拔
Serial.println(altitude);
```

### Vitepress Web端展示

有点饿了，下午再战，我从早上爬起来，到现在还没吃过一口饭呢。

这个我就不说明了，直接放在网上了，你拿蓝牙连接好就可以了。

## 最后是警报部分

### 蜂鸣器

准备一个有源蜂鸣器，无源蜂鸣器代码部分太麻烦了。

接线：

```cpp
BUZZER    |     Arduino
+               BUZZER_PIN
-               GND
```

代码：
```cpp
void setup() {
	pinMode(BUZZER_PIN, OUTPUT);
}

void loop() {
	if (temperature > 42){
		digitalWrite(BUZZER_PIN, HIGH);
	}else {
		digitalWrite(BUZZER_PIN, LOW);
	}
}
```

### LED

接线：

```cpp
LED     |     Arduino
+             LED_PIN
-             GND
```

代码：

```cpp

void setup(){
	pinMode(LED_PIN, OUTPUT);
}

void loop(){
	uint32_t curr = millis();
	static uint32_t p1 = 0;
	if (temperature>42){
		if (curr - p1 > 400){
			p1 = curr;
		}
		
		if (curr - p1 < 200){
			digitalWrite(LED_PIN, HIGH);
		}else{
			digitalWrite(LED_PIN, LOW);
		}
	}else {
		digitalWrite(LED_PIN, LOW);
		p1 = 0;
	}
}
```

## 参考资料

1. 【李徽发的PKM】 https://github.com/euuen/PKM
2. 【Arduino引脚分布说明】 https://www.cnblogs.com/Bruce_H21/p/11555605.html
3. 【Arduino教程】 https://arduino.me/s/arduino-getting-started?aid=318
4. 【Arduino使用按键】 https://arduino.me/s/arduino-getting-started?aid=642

# 优化过后的小陈的代码（未同步，先不管了）

```cpp
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <DHT.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Adafruit_BMP280.h>

// 引脚定义
#define DHTPIN 2
#define PIRPIN 3
#define LIGHTPIN A0
#define OLED_RESET -1 // 如果你的OLED没有RESET引脚，就设为-1

#define BUZZER_PIN 12
#define LED_PIN 13

// 传感器类型定义
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);
Adafruit_SSD1306 display(128, 64, &Wire, OLED_RESET);

// 变量定义
bool personDetected = false;
int lightLevel = 0;
float h = 0;
float t = 0;
Adafruit_BMP280 bmp;
int sensorPin =4;
void setup() {
  pinMode(4,INPUT);
  // 初始化串口，用于调试
  Serial.begin(9600);
  bmp.begin(0x76);
  bmp.setSampling(
    Adafruit_BMP280::MODE_NORMAL,
    Adafruit_BMP280::SAMPLING_X16,
    Adafruit_BMP280::SAMPLING_X2,
    Adafruit_BMP280::FILTER_X16,
    Adafruit_BMP280::STANDBY_MS_500
  );


  // 初始化OLED显示屏
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  display.display();
  display.clearDisplay();
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0,0);
  display.println("System Init...");
  display.display();
  delay(2000);

  // 初始化DHT11传感器
  dht.begin();

  // 设置PIR传感器引脚为输入模式
  pinMode(PIRPIN, INPUT);

  // 蜂鸣器
  pinMode(BUZZER_PIN, OUTPUT);

  // LED
  pinMode(LED_PIN, OUTPUT);
}

void loop() {
  int motionState = digitalRead(sensorPin);
  if(motionState==HIGH){
    Serial.println("监测到人体移动");
  }else{
    Serial.println("无移动");
  }
  float temperature = bmp.readTemperature();  // ℃
  float pressure = bmp.readPressure() / 100;  // hPa
  
  // 输出结果（文档1表2：相对精度±0.12hPa）
  Serial.print("Temperature: ");
  Serial.print(temperature);
  Serial.println(" °C");
  
  Serial.print("Pressure: ");
  Serial.print(pressure);
  Serial.println(" hPa");
  
  Serial.println("-----------------");

  uint32_t curr = millis();
  static uint32_t p1 = 0;
  // 读取所有传感器数据
  if (curr - p1 > 2000){
    p1 = curr;
    readSensors();
  }

  // 在串口监视器打印数据（用于调试和查看原始数据）
  static uint32_t p2 = 0;
  if (curr - p2 > 200){
      p2 = curr;
      printSerialData();
  }
  
  if (1) {
      // 在OLED屏幕上显示数据
      displayOLEDData();
  }
  
  // 大于42度
  static uint32_t p3 = 0;
  if (t > 20){
      digitalWrite(BUZZER_PIN, HIGH);
      if (curr - p3 > 400){
          p3 = curr;
      }
      
      if (curr - p3 < 200){
          digitalWrite(LED_PIN, HIGH);
      }else{
          digitalWrite(LED_PIN, LOW);
      }
  }else{
      digitalWrite(BUZZER_PIN, LOW);
      digitalWrite(LED_PIN, LOW);
      p3 = 0;
  }
}

void readSensors() {
  // 读取人体红外传感器
  personDetected = digitalRead(PIRPIN);

  // 读取光强（模拟值0-1023，值越大光越强）
  lightLevel = analogRead(LIGHTPIN);

  // DHT11和BMP280的读取已经在各自显示函数中完成
  h=dht.readHumidity();
  t=dht.readTemperature();
}

void printSerialData() {
  Serial.println("------ Environmental Data ------");

  // 温湿度 (DHT11)
  // float h = dht.readHumidity();
  // float t = dht.readTemperature();
  // 移动到函数外面了
  Serial.print("Humidity: "); Serial.print(h); Serial.println(" %");
  Serial.print("Temperature: "); Serial.print(t); Serial.println(" *C");
  
  // 环境光
  Serial.print("Light: ");
  Serial.println(lightLevel);

  // 人体感应
  Serial.print("Person: "); 
  Serial.println(personDetected ? "Detected!" : "Not detected");

  Serial.println("--------------------------------");
}

void displayOLEDData() {
  display.clearDisplay();
  display.setCursor(0,0);

  // 第一行：温湿度
  display.print("T:");
  display.print(t,1);
  display.print("C H:");
  display.print(h,0);
  display.println("%");

  // 第三行：海拔和光强
  display.print("Light: ");
  display.println(lightLevel);

  // 第四行：人体感应
  display.print("Person: ");
  if (personDetected) {
    display.println("YES!");
  } else {
    display.println("no");
  }

  display.display();
}
```

# 我的代码

接线：

| I2C      | SCL  | A5  | OLED | BMP280 | VEML7700 |
| -------- | ---- | --- | ---- | ------ | -------- |
|          | SDA  | A4  | 0x3C | 0x76   |          |
| DHT11    | DATA | 7   |      |        |          |
| HCSR501  | OUT  | 4   |      |        |          |
| BUZZER   | +    | 12  |      |        |          |
| LED      | +    | 13  |      |        |          |
| BUTTON_A | +    | 2   |      |        |          |
| BUTTON_B | +    | 3   |      |        |          |
| HC05     | RX   | TX  |      |        |          |
|          | TX   | RX  |      |        |          |
|          |      |     |      |        |          |

代码：

```cpp
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <DHT.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Adafruit_BMP280.h>
#include <Adafruit_VEML7700.h> // 包含Adafruit的VEML7700库

// 引脚分布
#define LED_PIN 13
#define BUZZER_PIN 12
#define HCSR501_PIN 4
#define DHT11_PIN 7
#define BUTTON_A 2
#define BUTTON_B 3

#define DHT_TYPE DHT11

// MAGIC NUMBER
#define CHECK_INTER 2000
#define IS_ALWAYS_ON true
// 滚动画面
#define LOOP_ON ture

// OLED 配置参数
#define SCREEN_WIDTH 128 // 屏幕宽度（像素）
#define SCREEN_HEIGHT 32 // 屏幕高度（像素）
#define OLED_ADDR 0x3C   // I2C 地址（根据你的屏幕修改，常见0x3C或0x3D）

// 设备类型
#define NODEVICE_ON 0
#define DHT11_ON 1
#define VEML7700_ON 2
#define BMP280_ON 3

DHT dht(DHT11_PIN, DHT_TYPE);  // 初始化 DHT 对象
Adafruit_VEML7700 veml = Adafruit_VEML7700();  // 创建光照传感器对象
Adafruit_BMP280 bmp; // 气压传感器
// 初始化一个 Adafruit_SSD1306 对象
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

float humidity = 78;
float temperature = 28;
float lux = 300;
float pressure = 1006;
float altitude = 49.5;
int motion = LOW;

volatile int current_device = NODEVICE_ON;

void moveLeft(){
	current_device--;
	if (current_device < 0) current_device = 3;
}

void moveRight(){
	current_device++;
	if (current_device > 3) current_device = 0;
}

void setup(){
	// 初始化普通引脚
	pinMode(LED_PIN, OUTPUT);
	pinMode(BUZZER_PIN, OUTPUT);
	pinMode(HCSR501_PIN, INPUT);
	pinMode(BUTTON_A, INPUT_PULLUP);
	pinMode(BUTTON_B, INPUT_PULLUP);
	// 看情况用FALLING还是RISING
	attachInterrupt(digitalPinToInterrupt(BUTTON_A), moveLeft, RISING);
	attachInterrupt(digitalPinToInterrupt(BUTTON_B), moveRight, RISING);
	
	// 初始化
	Serial.begin(9600);
	dht.begin();
	if (!veml.begin()) {
		Serial.println("VEML 初始化失败");
		while (1); // 停止执行
	}
	if (!display.begin(SSD1306_SWITCHCAPVCC, OLED_ADDR)){
		Serial.println("OLED 初始化失败");
		while (1); // 停止执行
	}
	if (!bmp.begin(0x76)) { // 尝试0x76，失败则试0x77
		Serial.println("BMP280未找到！检查接线或地址！");
		while (1); // 停止执行
	}
	bmp.setSampling(
		Adafruit_BMP280::MODE_NORMAL,     // 模式（正常/睡眠/强制）
		Adafruit_BMP280::SAMPLING_X2,     // 温度采样
		Adafruit_BMP280::SAMPLING_X16,    // 气压采样
		Adafruit_BMP280::FILTER_X16,      // 滤波
		Adafruit_BMP280::STANDBY_MS_500   // 待机时间
	);
	// 清除显示缓冲区
	display.clearDisplay();
	// 设置文字颜色为白色
	display.setTextColor(SSD1306_WHITE);
	// 刷新OLED
	display.display();
}

void loop(){

	uint32_t curr = millis();
	
	static uint32_t p1 = 0;
	if (curr - p1 > CHECK_INTER){
		p1 = curr;
		humidity = dht.readHumidity();
		if (!isnan(humidity)){
			Serial.print("humidity: ");
			Serial.println(humidity);
		}else {
			Serial.print("humidity: ");
			Serial.println("ERROR NAN");
		}
		temperature = dht.readTemperature();
		if (!isnan(temperature)){
			Serial.print("temperature: ");
			Serial.println(temperature);
		}else {
			Serial.print("temperature: ");
			Serial.println("ERROR NAN");
		}
		lux = veml.readLux();
		if (!isnan(lux)){
			Serial.print("lux: ");
			Serial.println(lux);
		}else {
			Serial.print("lux: ");
			Serial.println("ERROR NAN");
		}
		pressure = bmp.readPressure();
		if (!isnan(pressure)){
			Serial.print("pressure: ");
			Serial.println(pressure);
		}else {
			Serial.print("pressure: ");
			Serial.println("ERROR NAN");
		}
		altitude = bmp.readAltitude(1010.0);   // 长沙的平均海平面气压
		if (!isnan(altitude)){
			Serial.print("altitude: ");
			Serial.println(altitude);
		}else {
			Serial.print("altitude: ");
			Serial.println("ERROR NAN");
		}
		motion = digitalRead(HCSR501_PIN);
	}
	
	static uint32_t p2 = 0;
	if (LOOP_ON){
		if (curr - p2 > 2000){
			p2 = curr;
			current_device++;
			if (current_device > 3){
				current_device = 0;
			}
			// 防止意外发生
			if (current_device < 0){
				current_device = 3;
			}
		}
	}
	
	static uint32_t p3 = 0;
	if (temperature > 42){
		if (curr - p3 > 400){
			p3 = curr;
		}
		
		if (curr - p3 < 200){
			digitalWrite(BUZZER_PIN, HIGH);
			digitalWrite(LED_PIN, HIGH);
		}else {
			digitalWrite(BUZZER_PIN, LOW);
			digitalWrite(LED_PIN, LOW);
		}
	}else {
		p3 = 0;
	}
	
	if (IS_ALWAYS_ON || motion == HIGH){
		switch (current_device){
		case NODEVICE_ON:
			display.clearDisplay();
			display.setCursor(0, 0);
			display.setTextSize(1);
			display.println("MADE BY");
			display.setTextSize(3);
			display.println("CSUST");
			display.display();
			break;
		case DHT11_ON:
			display.clearDisplay();
			display.setCursor(0, 0);
			display.setTextSize(1); 
			display.println("humidity: ");
			display.println(humidity);
			display.println("temperature: ");
			display.println(temperature);
			display.display();
			break;
		case VEML7700_ON:
			display.clearDisplay();
			display.setCursor(0, 0);
			display.setTextSize(1); 
			display.println("lux: ");
			display.println(lux);
			display.display();
			break;
		case BMP280_ON:
			display.clearDisplay();
			display.setCursor(0, 0);
			display.setTextSize(1); 
			display.println("pres: ");
			display.println(pressure);
			display.println("altitude: ");
			display.println(altitude);
			display.display();
			break;
		default :
			display.clearDisplay();
			display.setCursor(0, 0);
			display.setTextSize(1); 
			display.println("ERROR");
			display.setTextSize(2); 
			display.println("No Device");
			display.display();
			break;
		}
	}
}
```

# 方案2

```cpp
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// OLED 配置参数
#define SCREEN_WIDTH 128 // 屏幕宽度（像素）
#define SCREEN_HEIGHT 32 // 屏幕高度（像素）
#define OLED_ADDR 0x3C   // I2C 地址（根据你的屏幕修改，常见0x3C或0x3D）

// 初始化一个 Adafruit_SSD1306 对象
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, -1);

float humidity = 78;
float temperature = 28;
float lux = 300;
float pressure = 1006;
float altitude = 49.5;
int motion = LOW;

void setup(){
	Serial.begin(9600);
	// 初始化dispaly
	display.begin(SSD1306_SWITCHCAPVCC, OLED_ADDR);
	// 清除显示缓冲区
	display.clearDisplay();
	// 设置文字颜色为白色
	display.setTextColor(SSD1306_WHITE);
	// 刷新OLED
	display.display();
}

void loop(){
	Serial.print("humidity: ");
	Serial.println(humidity);
	Serial.print("temperature: ");
	Serial.println(temperature);
	Serial.print("pressure: ");
	Serial.println(pressure);
	Serial.print("altitude: ");
	Serial.println(altitude);
	delay(1000);
}
```

# 番外，BT24 Web Bluetooth API

## 什么是Web Bluetooth API

Web Bluetooth API是一组由 W3C 制定的 JavaScript API，它允许 Web 应用程序通过蓝牙低功耗（BLE）协议直接与附近的蓝牙设备进行通信

这意味着开发者可以在网页中实现蓝牙设备的搜索、连接和数据传输，而无需依赖原生应用程序或额外的插件

​​设备请求与筛选​​：通过调用 navigator.bluetooth.requestDevice()方法，浏览器会弹出设备选择器，用户可以从搜索到的设备中选择要连接的设备。开发者可以定义过滤器（filters）来指定要寻找的设备类型或服务

​​建立连接​​：用户选择设备后，使用 device.gatt.connect()方法建立与设备 GATT 服务器的连接

​​发现服务与特征值​​：连接成功后，通过 server.getPrimaryService(serviceUUID)获取所需服务，然后通过 service.getCharacteristic(characteristicUUID)获取特定的特征值（Characteristic）。特征值是数据读写操作的实际接口

​​数据交换​​：最后，使用 characteristic.readValue()读取数据，或使用 characteristic.writeValue()写入数据

还可以通过 startNotifications()方法启用通知，监听设备发来的数据

## 我的想法

本来想做的蓝牙的显示的，但是后发现HC05用的是SPP不是BLE，所以，就放弃了。不过还是学到了，如何用Web Bluetooth API和BT24通信的，因为今天没空，就只留下了代码部分：

```vue
<script setup lang="ts">
const BT24_SERVICE_UUID = 0xffe0; // 注意：Web Bluetooth API通常使用短UUID格式
const BT24_TX_CHARACTERISTIC_UUID = 0xffe1; // 假设用于接收模块数据（通知）
const BT24_RX_CHARACTERISTIC_UUID = 0xffe2; // 假设用于向模块发送数据（写）

let bt24Device = null;
let bt24Server = null;
let bt24Service = null;
let txCharacteristic = null; // 用于接收数据（通知）
let rxCharacteristic = null; // 用于发送数据（写）

async function getDevice(){
    bt24Device = await navigator.bluetooth.requestDevice({
        // acceptAllDevices : true,
        filters: [{
            services: [BT24_SERVICE_UUID] // 只显示提供此特定服务的设备
        }],
        optionalServices: [BT24_SERVICE_UUID]
    });

    bt24Server = await bt24Device.gatt.connect();
    bt24Service = await bt24Server.getPrimaryService(BT24_SERVICE_UUID);
    rxCharacteristic = await bt24Service.getCharacteristic(BT24_RX_CHARACTERISTIC_UUID);
    txCharacteristic = await bt24Service.getCharacteristic(BT24_TX_CHARACTERISTIC_UUID);
}

async function disconnectToBLE() {
    if (bt24Device && bt24Device.gatt.connected) {
        await bt24Device.gatt.disconnect();
    }
    
    bt24Device = null;
    bt24Server = null;
    bt24Service = null;
    rxCharacteristic = null;
    txCharacteristic = null;
}

async function Send(){
    const encoder = new TextEncoder()
    const dataBuffer = encoder.encode("hello world")
    await rxCharacteristic.writeValue(dataBuffer)
    // console.log(rxCharacteristic.writeValueWithoutResponse)
}

</script>

<template>
    <button @click = getDevice>Connect</button>
    <br></br>
    <button @click = Send>Send</button>
</template>
```