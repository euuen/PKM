A版
```c
/* main.c - 在main函数中添加 */
#include "string.h"

// 定义数据结构
typedef struct {
    int32_t data1;
    uint16_t data2;
    uint8_t flag;
} DataFrame;

void send_data_to_b(int32_t data1, uint16_t data2, uint8_t flag) {
    uint8_t tx_buffer[8]; // 4+1+2+1=8字节
    
    // 填充数据帧
    memcpy(&tx_buffer[0], &data1, 4);    // data1 (4字节)
    tx_buffer[4] = 0xAC;                 // 分隔符 (1字节)
    memcpy(&tx_buffer[5], &data2, 2);    // data2 (2字节)
    tx_buffer[7] = flag;                 // flag (1字节)
    
    // 发送数据
    HAL_UART_Transmit(&huart1, tx_buffer, 8, HAL_MAX_DELAY);
}

int main(void) {
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_USART1_UART_Init();
    
    // 测试数据
    int32_t test_data1 = 500;    // -1000到1000范围内
    uint16_t test_data2 = 300;    // 0到1000范围内
    uint8_t test_flag = 1;        // 0或1
    
    while (1) {
        send_data_to_b(test_data1, test_data2, test_flag);
        HAL_Delay(1000); // 每秒发送一次
        
        // 可以修改测试数据
        test_data1 = (test_data1 + 100) % 2000 - 1000;
        test_data2 = (test_data2 + 50) % 1001;
        test_flag = !test_flag;
    }
}
```

B版
```c
/* main.c */
#include "oled.h"
#include "font.h"
#include "string.h"
#include "stdio.h"

// 定义LED引脚
#define LED1_PIN GPIO_PIN_0
#define LED1_PORT GPIOC
#define LED2_PIN GPIO_PIN_1  
#define LED2_PORT GPIOC
#define LED3_PIN GPIO_PIN_2
#define LED3_PORT GPIOC
#define LED4_PIN GPIO_PIN_3
#define LED4_PORT GPIOC

// 定义数据范围
#define RANGE1_MIN -1000
#define RANGE1_MAX 0
#define RANGE2_MIN 1
#define RANGE2_MAX 1000
#define RANGE3_MIN 1001
#define RANGE3_MAX 1500
#define RANGE4_MIN 1501
#define RANGE4_MAX 2000

// 全局变量
int32_t received_data = 0;
uint8_t received_flag = 0;
char display_text[20];

// 控制LED函数
void control_leds(int32_t data) {
    // 先关闭所有LED
    HAL_GPIO_WritePin(LED1_PORT, LED1_PIN, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(LED2_PORT, LED2_PIN, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(LED3_PORT, LED3_PIN, GPIO_PIN_RESET);
    HAL_GPIO_WritePin(LED4_PORT, LED4_PIN, GPIO_PIN_RESET);
    
    // 根据数据范围点亮对应的LED
    if (data >= RANGE1_MIN && data <= RANGE1_MAX) {
        HAL_GPIO_WritePin(LED1_PORT, LED1_PIN, GPIO_PIN_SET);
    } else if (data >= RANGE2_MIN && data <= RANGE2_MAX) {
        HAL_GPIO_WritePin(LED2_PORT, LED2_PIN, GPIO_PIN_SET);
    } else if (data >= RANGE3_MIN && data <= RANGE3_MAX) {
        HAL_GPIO_WritePin(LED3_PORT, LED3_PIN, GPIO_PIN_SET);
    } else if (data >= RANGE4_MIN && data <= RANGE4_MAX) {
        HAL_GPIO_WritePin(LED4_PORT, LED4_PIN, GPIO_PIN_SET);
    }
}

// OLED显示函数
void update_oled_display(int32_t data, uint8_t flag) {
    OLED_NewFrame(); // 开始新的一帧
    
    if (flag) {
        // 如果flag为1，显示数据
        snprintf(display_text, sizeof(display_text), "Data: %ld", data);
        OLED_PrintString(0, 0, display_text, &font16x16, OLED_COLOR_NORMAL);
    } else {
        // 如果flag为0，显示提示信息或清空
        OLED_PrintString(0, 0, "Waiting...", &font16x16, OLED_COLOR_NORMAL);
    }
    
    OLED_ShowFrame(); // 显示帧
}

// UART接收完成回调函数
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    if (huart->Instance == USART1) {
        // 数据接收完成，可以在这里处理
    }
}

int main(void) {
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_USART1_UART_Init();
    MX_I2C1_Init();
    
    // 初始化OLED
    OLED_Init();
    OLED_DisPlay_On();
    
    uint8_t rx_buffer[8];
    
    while (1) {
        // 接收数据
        if (HAL_UART_Receive(&huart1, rx_buffer, 8, 1000) == HAL_OK) {
            // 检查分隔符是否正确
            if (rx_buffer[4] == 0xAC) {
                // 解析数据
                int32_t data1;
                uint16_t data2;
                
                memcpy(&data1, &rx_buffer[0], 4);
                memcpy(&data2, &rx_buffer[5], 2);
                uint8_t flag = rx_buffer[7];
                
                // 计算data
                received_data = data1 + data2;
                received_flag = flag;
                
                // 控制LED
                control_leds(received_data);
                
                // 更新OLED显示
                update_oled_display(received_data, received_flag);
            }
        }
        
        HAL_Delay(100);
    }
}

/* 在main.h中添加函数声明 */
void control_leds(int32_t data);
void update_oled_display(int32_t data, uint8_t flag);
```

#!/usr/bin/bash

openocd -f interface/stlink-v2.cfg -f target/stm32f1x.cfg -c "program build/Release/test4.elf verify reset exit"

### LED控制效果：

根据计算出的`data = data1 + data2`的值，点亮不同的LED灯：

|数据范围|对应的LED|实际数值范围|
|---|---|---|
|-1000 ~ 0|LED1亮|数据较小或负值|
|1 ~ 1000|LED2亮|中等数值|
|1001 ~ 1500|LED3亮|较大数值|
|1501 ~ 2000|LED4亮|最大数值|
```c
// 在初始化部分添加
uint8_t rx_buffer[8];
HAL_UART_Receive_IT(&huart1, rx_buffer, 8);

// 修改回调函数
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
    if (huart->Instance == USART1) {
        // 立即处理数据
        if (rx_buffer[4] == 0xAC) {
            int32_t data1;
            uint16_t data2;
            
            memcpy(&data1, &rx_buffer[0], 4);
            memcpy(&data2, &rx_buffer[5], 2);
            uint8_t flag = rx_buffer[7];
            
            received_data = data1 + data2;
            received_flag = flag;
            
            control_leds(received_data);
            update_oled_display(received_data, received_flag);
        }
        
        // 重新启动接收
        HAL_UART_Receive_IT(&huart1, rx_buffer, 8);
    }
}

```