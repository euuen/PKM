# C语言
## volatile
1. 一句话理解：编译器运行时为了提高效率，可能从寄存器直接读取变量值，但是变量值改变时，可能还没来得及从内存映射到寄存器中，导致编译器读取的值是错误的。
2. volatile的关键作用就是阻止这类优化。它强制要求编译器：
每次访问变量时都必须直接从其内存地址中读取，不能使用CPU寄存器中的缓存值。
每次修改变量时都必须立即写回其内存地址，不能延迟或合并写操作。
```c
// 情况1：无 volatile
int *pReg = (int*)0x40020000;
*pReg = 1; // 编译器可能优化此行
*pReg = 2; // 认为上一行写入无关紧要

// 情况2：有 volatile
volatile int *pReg = (volatile int*)0x40020000;
*pReg = 1; // 必须执行
*pReg = 2; // 必须执行
```

## const
1. 作用：修饰一个不可变的常量
2. 

|主要应用场景|关键点说明|代码示例（简要）|
|---|---|---|
|**定义常量**​|替代宏定义(`#define`)，有类型检查，更安全。|`const int MAX_SIZE = 100;`|
|**修饰指针**​|1. 指向常量（指针可变，内容不可变）  <br>2. 常量指针（内容可变，指针不可变）  <br>3. 指向常量的常量指针（都不可变）|`const int *p;`  <br>`int* const p = &a;`  <br>`const int* const p = &a;`|
|**修饰函数参数**​|防止函数内部意外修改传入的参数，尤其用于指针或引用参数以保护原始数据。|`void print(const char* str);`|
|**修饰函数返回值**​|防止函数返回值被作为左值修改（较少使用，多见于运算符重载）。|`const int getValue();`|
|**在C++类中**​|1. 修饰成员函数：该函数不能修改类的成员变量（常成员函数）。  <br>2. 修饰对象：该对象只能调用常成员函数（常对象）。|`int get() const { return value; }`  <br>`const MyClass obj;`|
3. 
- **判断 `const`修饰对象的口诀**
    当 `const`和指针结合时，一个简单的判断规则是：**以 `*`号为界**​ 。
    - `const`在 `*`的**左边**，表示指针指向的数据是常量（如 `const int *p`或 `int const *p`）。
    - `const`在 `*`的**右边**，表示指针变量本身是常量（如 `int * const p`）。


```c
#define     __I     volatile const   // 只读（如状态寄存器）
#define     __O     volatile         // 只写
#define     __IO    volatile         // 可读可写
```

## static

| 应用语言/环境       | 修饰目标 | 核心作用   | 关键点说明                   |
| ------------- | ---- | ------ | ----------------------- |
| **C语言**​      | 局部变量 | 延长生命周期 | 函数调用结束后变量值保持，只初始化一次。    |
|               | 全局变量 | 限制作用域  | 使变量仅在定义它的源文件内可见，避免命名冲突。 |
|               | 函数   | 限制作用域  | 使函数仅在定义它的源文件内可调用，提高封装性。 |
| **C++/Java**​ | 成员变量 | 变量属于类  | 所有类实例共享同一变量，用于共享数据。     |
|               | 成员方法 | 方法属于类  | 方法可通过类名直接调用，不能访问非静态成员。  |
|               | 代码块  | 类初始化   | 在类加载时执行一次，用于初始化静态变量。    |

局部静态变量
普通局部变量在函数调用结束时就被销毁了。而用 static修饰的局部变量，虽然它的作用域仍然仅限于该函数内部（在函数外不可见），但它的生命周期却贯穿整个程序的运行期，且只初始化一次。这常用于记录函数被调用的次数，或在多次调用间保留某些状态。
```c
#include <stdio.h>
void counter() {
    static int count = 0;  // 只初始化一次
    count++;
    printf("Count: %d\n", count);
}
int main() {
    counter();  // 输出 "Count: 1"
    counter();  // 输出 "Count: 2"
    counter();  // 输出 "Count: 3"
    return 0;
}
```

## extern
| 用途                            | 描述                                                                                    | 代码示例                                                                                                |
| ----------------------------- | ------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- |
| **声明全局变量**​                   | 在一个源文件中定义全局变量，在其他源文件中使用 `extern`声明该变量，从而实现共享。                                         | `// file1.c`  <br>`int global_var =10;`  <br>  <br>`// file2.c`  <br>`extern int global_var;`       |
| **声明函数**​                     | 声明在其他文件中定义的函数。虽然函数默认具有外部链接性，通常可省略 `extern`，但显式使用可使意图更清晰。                              | `// file1.c`  <br>`void my_func() { ... }`  <br>  <br>`// file2.c`  <br>`extern void my_func();`    |
| **链接C和C++代码**​ (`extern "C"`) | 在C++代码中引用C语言编写的函数或变量时，使用 `extern "C"`来指示编译器使用C语言的命名和链接约定，防止名称修饰（name mangling）导致链接错误。 | `// C++ 文件 (main.cpp)`  <br>`extern "C" {`  <br>`#include "my_c_lib.h"`  <br>`}`                    |
| **修饰const常量**​                | 默认情况下，全局`const`变量具有内部链接性（仅当前文件可见）。使用`extern`可使其具有外部链接性，从而在其他文件中可用。                    | `// fileA.cpp`  <br>`extern const int i = 42;`  <br>  <br>`// fileB.cpp`  <br>`extern const int i;` |
## error
```c
#error 错误信息
```
1. 当预处理器在编译的早期阶段遇到 `#error`指令时，会立即中止编译流程，并将你指定的错误信息输出到编译器的错误信息中 。
```c
#include <stdio.h>

#if !defined(PRODUCT_LEVEL)
    #error 产品级别未定义！请在使用前定义PRODUCT_LEVEL（例如：-DPRODUCT_LEVEL=2）。
#elif (PRODUCT_LEVEL < 1) || (PRODUCT_LEVEL > 3)
    #error 产品级别定义错误！PRODUCT_LEVEL的有效值为1、2或3。
#endif

void main() {
#if (PRODUCT_LEVEL == 1)
    printf("基础版功能\n");
#elif (PRODUCT_LEVEL == 2)
    printf("专业版功能\n");
#elif (PRODUCT_LEVEL == 3)
    printf("企业版功能\n");
#endif
}
```

## `#if、#elif、#else、#endif、#ifdef、#ifndef`
```c
#if 整型常量表达式1
  程序段1
#elif 整型常量表达式2
  程序段2
#else
  程序段3
#endif
```
1. 如果整形常量表达式为真，则执行程序段1，以此类推，最后#endif是#if的结束标志
```c
#ifdef  宏名
  程序段1
#else
  程序段2
#endif
```
2. 如果该宏已被定义过，则对程序段1进行编译，否则对程序段2进行编译，通#if一样，#endif也是#ifdef的结束标志
*#ifndef*的作用与#ifdef的作用相反，用于判断某个宏是否没被定义。
3. *#if defined*、*#if !defined
*#ifdef和#ifndef*仅能一次判断一个宏名，而*defined*能做到一次判断多个宏名
```c
#if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
// ......
#endif /* STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
```
```c
#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
#endif
```

## 数据类型


| 数据类型          | 别名/等价类型             | 占用字节数 | 数值范围                  | 主要用途与说明                       |
| ------------- | ------------------- | ----- | --------------------- | ----------------------------- |
| **uint8_t**​  | u8, unsigned char   | 1 字节  | 0 到 255               | 处理8位寄存器、状态标志、小范围计数、RAW数据缓冲区   |
| **int8_t**​   | s8, signed char     | 1 字节  | -128 到 127            | 处理小范围有符号数据，如微小变化的传感器读数        |
| **uint16_t**​ | u16, unsigned short | 2 字节  | 0 到 65,535            | **ADC转换结果**(12位ADC)、16位定时器计数值 |
| **int16_t**​  | s16, signed short   | 2 字节  | -32,768 到 32,767      | 有符号传感器数据（如加速度计）、PID控制器输出      |
| **uint32_t**​ | u32, unsigned long  | 4 字节  | 0 到 4,294,967,295     | 存储较大计数值（如微秒时间戳）、操作内存地址        |
| **int32_t**​  | s32, signed int     | 4 字节  | -2.1×10⁹ 到 2.1×10⁹    | 通用有符号整数运算，范围较大的有符号量           |
| **float**​    | fp32                | 4 字节  | ±3.4×10³⁸ (约6-7位有效数字) | 需要小数点的运算、复杂数学计算（PID、滤波器）      |
| **double**​   | fp64                | 8 字节  | ±1.7×10³⁰⁸ (约15位有效数字) | 需要高精度的计算（在STM32中较少使用）         |

## typedef
**宏定义的新名字在左边，typedef的新名字在右边；**
**宏定义不需要分号，typedef需要分号；**
**宏定义任何名字都可以换，typedef只能专门给变量类型换名字；**
![[Pasted image 20251201104612.png]]

## 结构体
1. 将多个*不同类型*的*变量*组合成一个整体
2. 用struct关键字来定义结构体
```c

struct 结构体名称 {
    数据类型 成员1;
    数据类型 成员2;
    // ... 更多成员
};
```
3. 每次使用结构体时都要写`struct 结构体名`有点麻烦。使用`typedef`可以为结构体创建一个别名，从而简化代码
```c
// 定义结构体并同时创建别名Student
typedef struct {
    char name[50];
    int age;
    float gpa;
} Student; // 现在可以直接用Student声明变量

Student stu1; // 而不需要写struct Student stu1;
```
4. 初始化
```c
// 方法1: 按成员定义顺序初始化
Student student1 = {"张三", 20, 3.8};

// 方法2: 指定成员初始化(C99标准支持)
Student student2 = {.name = "李四", .age = 21, .gpa = 3.9};

// 方法3: 先声明后逐个赋值
Student student3;
strcpy(student3.name, "王五"); // 对于字符串数组，需要使用strcpy
student3.age = 19;
student3.gpa = 3.7;
```
5. 访问结构体成员
(1) **使用点运算符`.`**：当操作对象是结构体变量本身时使用
```c
Student s = {"小明", 20, 3.5};
printf("姓名: %s\n", s.name); // 使用.访问成员
printf("年龄: %d\n", s.age);
s.age = 21; // 修改成员值
```
(2) **使用箭头运算符`->`**：当操作对象是指向结构体的*指针*时使用
```c
Student s = {"小明", 20, 3.5};
Student *ptr = &s; // ptr是指向结构体s的指针

printf("姓名: %s\n", ptr->name); // 使用->访问成员
ptr->age = 22; // 通过指针修改成员值
```
6. 结构体数组
```c
Student class[3] = {
    {"张三", 20, 3.8},
    {"李四", 21, 3.9},
    {"王五", 19, 3.7}
};

// 访问数组中的结构体成员
for(int i = 0; i < 3; i++) {
    printf("学生%d: %s, %d岁, GPA: %.1f\n", 
           i+1, class[i].name, class[i].age, class[i].gpa);
}
```
7. 嵌套结构体
```c
// 先定义一个地址结构体
typedef struct {
    char street[100];
    char city[50];
    int zipcode;
} Address;

// 在学生结构体中嵌套地址结构体
typedef struct {
    char name[50];
    int age;
    float gpa;
    Address address; // 嵌套结构体
} Student;

// 初始化嵌套结构体
Student student = {
    "小明", 
    20, 
    3.8, 
    {"人民路123号", "北京市", 100000} // 初始化嵌套的地址结构体
};

// 访问嵌套结构体成员
printf("城市: %s\n", student.address.city);
```

## 联合体
1. 允许你在**同一块内存空间**中存储*不同类型*的数据
```c
#include <stdio.h>

typedef union {
    int a;
    int b;
    int c;
} SharedUnion;

int main() {
    SharedUnion u;
    u.a = 10;
    u.b = 20;  // 这会覆盖 u.a 的值
    u.c = 30;  // 这会覆盖 u.b 的值
    
    printf("u.a = %d, u.b = %d, u.c = %d\n", u.a, u.b, u.c);
    // 输出结果：u.a = 30, u.b = 30, u.c = 30
    // 因为所有成员共享同一块内存
    
    return 0;
}
```

## 枚举
1. 用户自定义的数据类型，用于定义一组相关的命名整数常量

| 特性对比         | 结构体 (struct)                       | 枚举 (enum)                          |
| ------------ | ---------------------------------- | ---------------------------------- |
| **核心语义**​    | **“且” (AND)**​ - 所有成员共同组成一个完整的数据实体 | **“或” (OR)**​ - 任一时刻，多个可能的值中只有一个有效 |
| **成员/常量关系**​ | 成员**共存**于同一结构体变量中，可同时访问            | 常量**互斥**，一个枚举变量在同一时刻只能取一个常量值       |
| **内存占用**​    | 内存大小至少是所有成员大小之和（考虑内存对齐）            | 通常等同于一个`int`类型的大小（如4字节）            |
| **主要用途**​    | 描述具有多个属性的复杂对象，如学生、坐标等              | 表示状态、选项、分类等离散值的集合，如星期、开关状态         |
| **数据承载**​    | 每个成员都可以存储独立的数据                     | 常量本身通常是整数值，不直接存储额外数据（C语言中）         |
3. 状态机
```c
typedef enum {
    STATE_IDLE,     // 空闲状态
    STATE_RUNNING,  // 运行状态
    STATE_PAUSED,   // 暂停状态
    STATE_STOPPED   // 停止状态
} SystemState;

SystemState currentState = STATE_IDLE;
```

## 宏
1. **带参宏（函数式宏）**：类似于函数，但本质是文本替换。**参数和整个表达式一定要用括号括起来**，以避免运算符优先级导致的意外错误
```c
// 正确做法：充分使用括号
#define SQUARE(x) ((x) * (x))
#define MAX(a, b) (((a) > (b)) ? (a) : (b))

int result = SQUARE(1 + 2); // 展开为：((1 + 2) * (1 + 2)) = 9，结果正确
```
2. **多行宏的定义**：对于需要多行代码的复杂宏，使用 `do { ... } while(0)`结构进行封装。这样做可以确保宏在被调用时，无论后面是否跟着分号，其行为都像一个独立的语句，并且能正确地在 `if`等条件语句中使用
```c
#define SWAP_INT(a, b) do { \
    int temp = (a); \
    (a) = (b); \
    (b) = temp; \
} while(0)
```
###  `#和##运算符`
1. **字符串化运算符（`#`）**：将*宏的参数*直接转换为*字符串常量*
```c
#define STRINGIFY(x) #x
printf(STRINGIFY(Hello World)); // 相当于 printf("Hello World");
```
2. **连接运算符（`##`）**：将两个标记（Token）连接成一个
```c
#define CONCAT(a, b) a##b
int myVar = 10;
printf("%d", CONCAT(my, Var)); // 相当于 printf("%d", myVar); 输出 10
```

| 特性    | 宏定义                                              | 函数                         |
| ----- | ------------------------------------------------ | -------------------------- |
| 处理时机  | **编译前**，由预处理器进行文本替换。                             | **运行时**，由CPU执行调用。          |
| 性能开销​ | 无函数调用开销（如参数压栈、跳转、返回等），但可能造成代码膨胀（因为每次调用都会展开一次宏体）。 | 有函数调用开销，但代码只存在一份，节省空间。     |
| 类型检查​ | **无**。预处理器不进行语法和类型检查，不够安全。                       | **有**。编译器会检查参数和返回值类型，安全性高。 |
| 灵活性​  | 参数可以是任何类型（泛型），但容易因类型问题出错。                        | 参数类型必须严格匹配。                |
| 调试​   | 难以调试，因为调试器看到的是宏展开后的代码。                           | 易于调试。                      |

## 位操作？？？难

| 运算符  | 名称        | 运算规则                | 常见用途             |
| ---- | --------- | ------------------- | ---------------- |
| `&`  | **按位与**​  | 有0出0，全1出1           | 清零特定位、检查位状态、掩码操作 |
| `\|` | **按位或**   | 两个位有一个为1时，结果就为1<br> | 设置特定位为1、合并位字段    |
| `^`  | **按位异或**​ | 两个位不同时，结果为1         | 翻转特定位、交换变量值、简单加密 |
| `~`  | **按位取反**​ | 0变1，1变0             | 生成补码、创建掩码        |
| `<<` | **左移**​   | 各位左移，低位补0           | 乘以2的幂次、构造位字段     |
| `>>` | **右移**​   | 各位右移，高位补0或符号位       | 除以2的幂次、提取位字段     |
# 开发工具链
# STM32核心概念
## 型号 命名规则
| 字段            | 含义                                                                                                                                       | 示例1: `STM32F103C8T6` | 示例2: `STM32F407ZGT6` |
| ------------- | ---------------------------------------------------------------------------------------------------------------------------------------- | -------------------- | -------------------- |
| **STM32**​    | ST品牌的32位ARM Cortex-M内核微控制器                                                                                                               | STM32                | STM32                |
| **系列字母**​     | **产品系列定位**：  <br>• `F`: 通用型（主流）  <br>• `L`: 超低功耗  <br>• `H`: 高性能  <br>• `W`: 无线                                                          | `F`(通用型)             | `F`(通用型)             |
| **内核与子系列数字**​ | **芯片内核与性能等级**：  <br>• `0`: Cortex-M0/M0+ (入门级)  <br>• `1`: Cortex-M3 (主流级)  <br>• `4`: Cortex-M4 (支持DSP/FPU)  <br>• `7`: Cortex-M7 (高性能) | `1`(Cortex-M3)       | `4`(Cortex-M4)       |
| **引脚数**​      | **芯片的物理引脚数量**，决定可用的I/O口和外围接口数量。  <br>常见选项：`C`=48, `V`=100, `Z`=144, `I`=176。                                                             | `C`(48引脚)            | `Z`(144引脚)           |
| **闪存容量**​     | **内置Flash存储器的大小**，决定可存储程序代码的空间。  <br>常见选项：`8`=64KB, `B`=128KB, `G`=1MB, `I`=2MB。                                                         | `8`(64KB Flash)      | `G`(1MB Flash)       |
| **封装类型**​     | **芯片的物理封装形式**，影响焊接和PCB设计。  <br>常见选项：`T`=LQFP (带引脚), `H`=BGA (球栅阵列)。                                                                      | `T`(LQFP封装)          | `T`(LQFP封装)          |
| **温度范围**​     | **芯片正常工作的环境温度范围**。  <br>• `6`: -40°C 至 +85°C (工业级)  <br>• `7`: -40°C 至 +105°C (扩展工业级)                                                    | `6`(-40°C~85°C)      | `6`(-40°C~85°C)      |
## Flash and SRAM
| 特性维度      | Flash（闪存）                      | SRAM（静态随机存储器）                  |
| --------- | ------------------------------ | ------------------------------ |
| **本质作用**​ | **程序的“仓库”**​                   | **程序的“工作台”**​                  |
| **易失性**​  | **非易失**：断电后数据不丢失               | **易失**：断电后数据全部丢失               |
| **存储内容**​ | 程序代码（.text）、常量（.rodata）、中断向量表等 | 全局/局部变量、堆（heap）、栈（stack）等运行时数据 |
| **读写速度**​ | 较慢（特别是写入操作）                    | 很快                             |
| **编程方式**​ | 需先擦除再写入，写入次数有限                 | 可随时按字节读写                       |
| **典型容量**​ | 较大（STM32F103C8T6为64KB）         | 较小（STM32F103C8T6为20KB）         |
1. 简单来说，你编写好的程序在**下载后**就固化在**Flash**中；而当芯片上电运行后，需要被改变的数据（如变量）则会在**SRAM**中进行操作

|地址范围|功能描述|备注|
|---|---|---|
|`0x0000 0000`|**启动地址**​|根据BOOT引脚配置，映射到Flash、系统存储器或SRAM|
|`0x0800 0000`|**Flash主存储区起始地址**​|用户程序通常下载到此地址开始的空间|
|`0x2000 0000`|**SRAM起始地址**​|所有STM32型号的SRAM都起始于此|
|`0x4000 0000`|**外设寄存器起始地址**​|通过读写该区域的寄存器来控制芯片外设|

## 时钟树
1. 频率：单位时间内周期数（Hz），决定速度。
	周期：一个完整循环的时间（s），频率的倒数。
	占空比：高电平在一个周期内的占比，常为50%
2. **同步协调**：数字系统中的各个部件（如CPU、内存、外设）运算和处理速度有快有慢。时钟信号提供了一个统一的时间基准，确保所有操作按照预定的顺序和节奏进行。
3. **时序控制**：时钟信号决定了数据在数字电路中何时被读取、处理、传输和存储。例如，寄存器或触发器只有在时钟的有效边沿（上升沿或下降沿）才会捕获并更新其输出的数据状态。
4. CPU：CPU的主频（即核心时钟频率）是其性能的关键指标之一。这个频率可以在很大范围内配置（通过PLL倍频）
5. 内存：内存（如SDRAM）对时钟时序的要求非常严格，通常需要与CPU或内存控制器输出的时钟同步，并满足特定的建立/保持时间要求，否则会导致数据读写错误。一些高速内存接口（如DDR）还采用差分时钟信号以提高抗干扰能力。
6. 外设：不同外设根据其工作特性，对时钟有不同要求。
	固定频率需求：
		*USB接口：必须精确的48MHz时钟*，以确保符合USB通信协议的标准。
		实时时钟（RTC）：为了产生精确的1秒计时，RTC的时钟源通常连接32.768kHz的低速外部晶振（LSE）。这个频率经过15次分频后正好是1Hz
		UART（串口）：时钟频率（通常指其所在APB总线的频率PCLK）决定了通信波特率，需要在允许的误差范围内进行配置，以保证通信可靠性。
		定时器（Timer）：时钟频率决定了计数的快慢，可根据需要的定时精度和范围进行灵活分频或倍频。如果APB总线的分频系数不为1，定时器实际的时钟频率会是APB时钟的2倍。例如，当APB1时钟为36MHz时，其上的定时器时钟可能是72MHz
		ADC（模数转换器）：时钟频率决定了转换速度，但最高频率不能超过数据手册规定的最大值
		IWDG（独立看门狗）：固定为约40kHz（LSI），不可配置
		I2S：通常需要高精度的时钟源（如HSE）通过PLL来产生，以保障音频采样率的准确性。

## 电源与复位
# 内存与硬盘
1. 内存就像工作台，拿取速度快，但空间小。硬盘就像仓库，空间大，但拿取速度慢。
2. 仓库（硬盘）放着所有的程序和数据，而内存只存放当前正在运行的程序和需要被CPU立即处理的数据
3. CPU如何工作
取指：CPU的控制单元首先通过总线从内存中读取下一条要执行的指令，并将其放入指令寄存器中。
译码：指令译码器分析指令寄存器中的指令，确定CPU需要执行什么操作（比如是做加法还是数据移动），并解析出操作数在哪。
执行：根据译码结果，控制单元发出相应的控制信号，调度相关部件行动。如果需要计算，就将数据和操作命令送给运算逻辑单元；运算逻辑单元执行运算，并将结果存入指定寄存器或写回内存。

|特性维度|栈 (Stack)|堆 (Heap)|
|---|---|---|
|**管理方式**​|**自动管理**。由编译器自动分配和释放（如函数参数、局部变量）。|**手动管理**。由程序员手动申请和释放（如 `malloc`/ `free`, `new`/ `delete`）。|
|**空间大小**​|空间通常较小且有上限（如MB级），在编译或链接时确定。|空间相对更大，理论上可占用大部分可用内存，可以动态增长。|
|**分配效率**​|**高**。通常在硬件层级有专门支持，仅是移动栈指针，速度极快。|**较低**。分配算法需要寻找合适的内存块，可能产生碎片。|
|**数据结构特性**​|**线性结构**，遵循**后进先出**原则。|**树形结构**（常为完全二叉树），用于实现优先队列等。|
|**内存生长方向**​|通常由高地址向低地址“向下”生长。|通常由低地址向高地址“向上”生长。|

💾 静态内存分配
程序编译期间完成，主要包括全局变量、静态变量（由 static关键字修饰）以及常量。
优点：分配过程由编译器完成，简单高效，
缺点：缺乏灵活性。
🧱 栈内存分配
遵循后进先出的原则。主要存储局部变量、函数参数以及函数调用的返回地址等信息。
优点：分配和释放速度极快，仅需移动栈指针。由编译器自动管理，不易造成内存泄漏。
缺点：栈空间通常比较有限。过深的递归或过大的局部变量可能导致栈溢出。此外，存储在栈上的数据生命周期与函数绑定，一旦函数返回，其局部变量所占内存就会被回收。
🗑️ 堆内存分配
堆是一块更为灵活和庞大的内存区域，它允许程序在运行时动态申请任意大小的内存。这块内存的生命周期完全由程序员（或垃圾回收机制）控制，这带来了极大的灵活性，也带来了更高的管理复杂度。
存储内容：用于存放那些生命周期需要跨越多个函数调用，或者大小在运行时才能确定的数据，例如动态创建的链表、树等复杂数据结构。
分配方式：堆内存的分配和释放主要有两种方式：
手动管理（显式）：在C语言中，通过 malloc()、calloc()、realloc()等函数申请内存，使用完毕后必须调用 free()函数显式释放。
C++则使用 new和 delete操作符。
自动管理（隐式）：在Java、Python、JavaScript、Go等现代高级语言中，通常由垃圾回收机制自动检测并回收不再被引用的对象所占用的堆内存。
优点：空间巨大（主要受限于操作系统可用内存），生命周期灵活可控，能够应对复杂多变的内存需求

# GPIO
## 工作模式
| 工作模式        | 类型     | 核心特点                               | 典型应用场景                       |
| ----------- | ------ | ---------------------------------- | ---------------------------- |
| **浮空输入**​   | 输入     | 电平完全由外部信号决定，**悬空时不确定**，易受干扰        | 通信信号接收（如USART_RX）            |
| **上拉输入**​   | 输入     | 内部电阻将**悬空引脚默认拉至高电平**​              | 按键（接地式）、外部中断（下降沿/低电平触发）      |
| **下拉输入**​   | 输入     | 内部电阻将**悬空引脚默认拉至低电平**​              | 按键（接电源式）、外部中断（上升沿/高电平触发）     |
| **模拟输入**​   | 输入     | 关闭所有数字逻辑，直接读取**模拟电压信号**​           | ADC模数转换（连接光敏、烟雾传感器等）         |
| **推挽输出**​   | 输出     | 可**主动输出强高电平和强低电平**，驱动能力强           | 驱动LED、蜂鸣器、继电器，以及SPI、USART_TX |
| **开漏输出**​   | 输出     | **只能主动输出低电平**，高电平需**外部上拉电阻**实现     | I2C、SMBus等支持“线与”的总线，电平转换     |
| **复用推挽输出**​ | 输出（复用） | 推挽输出特性，但**输出信号由片内外设（如SPI、TIM）控制**​ | 用作PWM输出、SPI通信等               |
| **复用开漏输出**​ | 输出（复用） | 开漏输出特性，但**输出信号由片内外设（如I2C）控制**​     | 主要用于I2C通信                    |
如何选择工作模式？
1. 目标是读取外部信号：
	如果信号是连续变化的电压（如传感器）→ 模拟输入。
	如果信号是数字开关量：
		引脚悬空时希望是固定电平​ → 根据默认状态选择上拉输入（默认高）或下拉输入（默认低）。
		外部电路已能确保明确电平，或需要最真实反映外部信号 → 浮空输入。
2. 目标是驱动外部器件：
	需要直接输出高低电平驱动LED、数码管等 → 推挽输出。
	用于 I2C总线或需要连接不同电压等级的器件（电平转换）→ 开漏输出（必须外接上拉电阻）。
	引脚被用于串口、定时器等片内外设：
		根据外设要求选择复用推挽输出（如SPI、UART_TX）或复用开漏输出（如I2C）。

## 一些不错的例子
### 推挽输出 Output Push Pull
1. CubeMX配置：
GPIO mode-> Output Push Pull
GPIO Pull-up/Pull-down-> 根据需求选择（如无特殊要求可设为 No pull-up and no pull-down）
Maximum output speed-> 根据需求选择（低速Low可降低噪声，适用于LED；高速High适用于数字通信）
```c
//设置引脚输出高电平
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
//设置引脚输出低电平
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
//翻转引脚电平
HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
```
### 开漏输出 Output Open Drain
CubeMX配置：
GPIO mode-> Output Open Drain
注意：硬件设计时必须在引脚外部接上拉电阻。
代码操作：与推挽输出相同，使用 HAL_GPIO_WritePin和 HAL_GPIO_TogglePin。
### 上拉输入
CubeMX配置：
GPIO mode-> Input
GPIO Pull-up/Pull-down-> Pull-up
```c
// 在main.h文件的USER CODE BEGIN EM区域添加宏定义
#define KEY_A_Pin GPIO_PIN_0
#define KEY_A_GPIO_Port GPIOA
#define KEY_A  HAL_GPIO_ReadPin(KEY_A_GPIO_Port, KEY_A_Pin) // 读取按键状态
```

```c
// 在main.c的while(1)循环中
while (1) {
  if (KEY_A == GPIO_PIN_RESET) { // 检测按键是否被按下（低电平）
    HAL_Delay(10); // 延时约10ms以消除机械按键的抖动
    if (KEY_A == GPIO_PIN_RESET) { // 再次确认按键确实被按下
      // 等待按键松开（松手检测）
      while (KEY_A == GPIO_PIN_RESET);
      // 执行按键按下后的操作，例如翻转LED状态
      HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
    }
  }
  // 其他任务...
}
```
### 下拉输入
CubeMX配置：
GPIO mode-> Input
GPIO Pull-up/Pull-down-> Pull-down
### 浮空输入
CubeMX配置：
GPIO mode-> Input
GPIO Pull-up/Pull-down-> No pull-up and no pull-down
```c
//读取引脚电平
if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET) {
    // 引脚为高电平时的操作
} else {
    // 引脚为低电平时的操作
}
```
### 模拟输入
CubeMX配置：
GPIO mode-> Analog
GPIO Pull-up/Pull-down-> 通常设为 No pull-up and no pull-down
1. 模拟输入模式是关闭内部数字逻辑（施密特触发器）、上拉/下拉电阻，将GPIO引脚直接连接到片内ADC（模数转换器），用于读取连续变化的模拟电压信号，是连接传感器与数字世界的重要桥梁。
2. 典型应用：光敏电阻、摇杆、温度/压力传感器等模拟信号采集
#### 例子 ADC
1. 在引脚图中将所需引脚（例如PA0）设置为 `ADC1_IN0`。
2. 在 `Analog`选项卡下配置ADC参数，如分辨率、采样时间等。
```c
// 在main.c的while(1)循环中
int main(void)
{
  // 系统初始化...
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_ADC1_Init();
  MX_USART1_UART_Init(); // 如需串口打印

  uint16_t adc_value;
  float voltage;

  while (1)
  {
    HAL_ADC_Start(&hadc1); // 启动ADC转换
    // 等待转换完成，HAL_MAX_DELAY表示无限等待直至完成
    if (HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY) == HAL_OK)
    {
      adc_value = HAL_ADC_GetValue(&hadc1); // 获取12位ADC原始值
      voltage = (3.3f * adc_value) / 4095.0f; // 转换为电压值（假设Vref=3.3V）
      printf("ADC Value: %d, Voltage: %.3f V\r\n", adc_value, voltage);
    }
    HAL_Delay(500); // 延时500ms再采集
  }
}
```

```c
HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout);
```
函数会返回一个状态值，告诉你等待的结果：
HAL_OK：转换成功完成。
HAL_TIMEOUT：在指定的超时时间内，转换仍未完成。
HAL_ERROR：在等待过程中发生了错误

| 计算方法           | 核心公式                                      | 适用场景                     | 优点与注意事项                            |
| -------------- | ----------------------------------------- | ------------------------ | ---------------------------------- |
| **基础公式**​      | `电压值 (V) = (ADC原始值 / 4095) * 参考电压 (Vref)` | 参考电压（通常是VDD）稳定、精度要求不高的场景 | 简单直接，但精度直接受供电电压波动影响                |
| **内部参考电压校准法**​ | `电压值 (V) = 1.2 * (ADC原始值 / 内部参考电压ADC值)`   | 供电电压（VDD）不稳定或需要高精度测量的场景  | 精度高，结果基本由内部1.2V参考电压的精度决定，不受VDD波动影响 |

| 配置参数                                      | 功能说明               | 常用设置/选项                              |
| ----------------------------------------- | ------------------ | ------------------------------------ |
| **Clock Prescaler**​ (时钟预分频)              | 决定ADC模块的工作时钟频率     | 需确保分频后频率不超过芯片允许最大值（如F103为14MHz）      |
| **Resolution**​ (分辨率)                     | 设定ADC的转换精度         | 12位 (0-4095)、10位、8位等，精度越高，转换时间越长     |
| **Scan Conversion Mode**​ (扫描模式)          | 启用后可按顺序自动转换多个通道    | 多通道采集时需 **Enable**​                  |
| **Continuous Conversion Mode**​ (连续转换模式)  | 启用后ADC会自动开始下一次转换   | 需连续采集时 **Enable**，单次采集则 **Disable**​ |
| **Discontinuous Conversion Mode**​ (间断模式) | 每次触发只转换一个子序列       | 通常 **Disable**​                      |
| **Data Alignment**​ (数据对齐)                | 转换结果在数据寄存器中的对齐方式   | 通常选择 **Right alignment**​ (右对齐)      |
| **External Trigger Source**​ (外部触发源)      | 选择启动转换的触发信号        | **Software trigger**​ (软件触发) 或定时器触发  |
| **Number of Conversion**​ (转换通道数)         | 设置规则转换的通道总数        | 与实际使用的通道数量一致                         |
| **Rank**​ (序列)                            | 定义每个通道的转换顺序和采样时间   | 需为每个通道单独设置 **Sampling Time**​        |
| **Sampling Time**​ (采样时间)                 | 每个通道对输入电压进行采样的持续时间 | 时间越长，精度通常越高，但转换速度越慢                  |

### 复用推挽输出
CubeMX配置：
在引脚图上直接选择所需的外设功能（如SPI1_MOSI），软件会自动将模式设置为Alternate Function Push Pull。
### 复用开漏输出
CubeMX配置：
选择支持开漏输出的外设（如I2C1_SDA），软件会自动将模式设置为Alternate Function Open Drain。
复用功能注意事项：复用模式下，GPIO的初始化代码会由CubeMX在外设的初始化函数中自动生成，用户无需直接操作GPIO。

# 中断
| 优先级分组                                 | 抢占优先级位数 | 子优先级位数 | 抢占优先级值范围 | 子优先级值范围  | 适用场景                |
| ------------------------------------- | ------- | ------ | -------- | -------- | ------------------- |
| **Group 0**​ (`NVIC_PriorityGroup_0`) | 0位      | 4位     | 0（无抢占）   | 0-15     | 无嵌套，严格按顺序执行         |
| **Group 1**​ (`NVIC_PriorityGroup_1`) | 1位      | 3位     | 0-1      | 0-7      | 少量嵌套                |
| **Group 2**​ (`NVIC_PriorityGroup_2`) | 2位      | 2位     | 0-3      | 0-3      | **常用配置**，平衡嵌套与顺序    |
| **Group 3**​ (`NVIC_PriorityGroup_3`) | 3位      | 1位     | 0-7      | 0-1      | 多级嵌套                |
| **Group 4**​ (`NVIC_PriorityGroup_4`) | 4位      | 0位     | 0-15     | 0（无子优先级） | **FreeRTOS推荐**，完全嵌套 |
## STM32CubeMX 图形化配置
引脚模式与中断触发条件
在 Pinout & Configuration界面，找到并点击你准备用于*外部中断的GPIO引脚*（例如PA0）。
将其模式设置为 *GPIO_EXTIx*（x为中断线编号，例如 GPIO_EXTI0）
在左侧的 System Core-> GPIO设置中，点击该引脚进行详细配置：
*GPIO Mode*：选择中断触发条件，如上升沿 Rising Edge、下降沿 Falling Edge或双边沿 Rising/Falling Edge。注意，EXTI不支持高电平或低电平触发。
*GPIO Pull-up/Pull-down*：根据硬件电路选择上拉或下拉电阻。
NVIC（中断控制器）配置
在 *System Core-> NVIC*中，首先设置全局的 Priority Group（优先级分组），例如 2 bits for pre-emption priority（2位抢占优先级）。
在下方中断向量表中，找到并使能对应的EXTI中断线（如 EXTI line0 interrupt）。
为其设置 *Preemption Priority（抢占优先级）* 和 *Sub Priority（响应优先级）*。*数值越小，优先级越高*。特别注意，SysTick系统滴答定时器等系统中断的优先级通常较高，切勿将GPIO中断的抢占优先级设置为0，以免导致HAL_Delay等函数无法正常工作。

```c
/* USER CODE BEGIN 4 */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  /* 判断是哪个引脚产生的中断 */
  switch(GPIO_Pin)
  {
    case GPIO_PIN_0:  // 处理PA0的中断
      /* 简单的延时消抖，可根据实际情况调整或使用更高效的消抖方式 */
      HAL_Delay(10);
      /* 再次确认引脚电平，避免误触发 */
      if(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_RESET) 
      {
        /* 执行中断任务，例如翻转LED */
        HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
      }
      /* 中断标志位已在HAL库中自动清除，无需手动处理 */
      break;
    case GPIO_PIN_2:  // 可以处理其他引脚的中断，例如PE2
      // ... 其他中断的处理逻辑
      break;
    default:
      break;
  }
}
/* USER CODE END 4 */
```
1. **同一时间，一条中断线只能分配给一个GPIO端口使用**

## 中断标志位
| 特性        | 说明                                                                        |
| --------- | ------------------------------------------------------------------------- |
| **核心作用**​ | 指示某个特定的事件（中断源）是否已经发生。                                                     |
| **工作流程**​ | 事件发生 → 标志位置1 → CPU检测到 → 执行中断服务程序 → 标志位清除。                                 |
| **清除方式**​ | **自动清除**：硬件完成（如51单片机的定时器溢出标志TF0/TF1）。**手动清除**：软件指令完成（如51单片机的串口收发标志TI/RI）。 |
| **重要性**​  | 若未正确清除，会导致CPU反复进入同一中断，造成程序“卡死”。                                           |

| 外设/中断源              | 关键标志位                  | HAL库常规处理                                                                                                                           | 需要手动清除的典型场景                                                        |
| ------------------- | ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ |
| **外部中断 (EXTI)**​    | 线路中断挂起位 (Px)           | 通常在 `HAL_GPIO_EXTI_IRQHandler`中**自动清除**。                                                                                           | **关闭中断后重新开启前**，需先手动清除，以防残留标志位立即使程序再次进入中断。                          |
| **定时器 (TIM)**​      | 更新中断标志 (UIF)           | 在 `HAL_TIM_IRQHandler`中**自动处理**。                                                                                                   | 一般无需手动清除。但在使能定时器中断前，建议先清除一次标志位，避免一使能就立即进入中断。                       |
| **串口 (UART) - 接收**​ | 接收寄存器非空 (RXNE)         | 读取数据寄存器 (DR/RDR) 后**硬件自动清除**。                                                                                                      | 一般无需手动清除。                                                          |
| **串口 (UART) - 空闲**​ | 空闲线路检测 (IDLE)          | **取决于开启空闲中断的方式**。使用 `HAL_UARTEx_ReceiveToIdle_IT/DMA`时，HAL库可能自动清除；使用 `__HAL_UART_ENABLE_IT(&huart, UART_IT_IDLE)`使能时，**通常需要手动清除**。 | 使用`__HAL_UART_ENABLE_IT`使能空闲中断后，必须在空闲中断服务程序中手动清除IDLE标志位，否则会持续触发中断。 |
| **DMA**​            | 传输完成 (TCx), 传输过半 (HTx) | 在HAL库的DMA中断处理函数（如`HAL_DMA_IRQHandler`）中**自动清除**。                                                                                   | 如果未使用HAL库提供的DMA管理函数，而是直接操作寄存器，则必须手动清除这些标志位。                        |
| **串口错误**​           | 溢出错误 (ORE), 帧错误 (FE) 等 | HAL库的错误处理回调函数中可能不会自动清除所有错误标志。                                                                                                      | 在某些情况下，特别是出现Overrun错误时，需要手动清除错误标志位以恢复串口正常接收。                       |
1. 
```c
// 1. 禁用EXTI3中断
HAL_NVIC_DisableIRQ(EXTI3_IRQn);
// ... (执行一些不希望被中断打断的操作)
// 2. 在重新使能中断前，先清除可能残留的标志位
__HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_3);
// 3. 重新使能中断
HAL_NVIC_EnableIRQ(EXTI3_IRQn);
```
2. 串口空闲
如果你使用 __HAL_UART_ENABLE_IT(&huart, UART_IT_IDLE)来使能空闲中断，那么必须在中断服务函数中手动清除IDLE标志位。清除方法通常是先读取状态寄存器(SR)，再读取数据寄存器(DR)
```c
// 在USARTx_IRQHandler函数中
if(__HAL_UART_GET_FLAG(&huart, UART_FLAG_IDLE)) {
    __HAL_UART_CLEAR_IDLEFLAG(&huart); // 手动清除IDLE标志位
    // ... 处理空闲中断（如一帧数据接收完成）
}
HAL_UART_IRQHandler(&huart); // 仍然调用HAL库通用处理函数
```
3. 外设发生错误时
```c
// 清除串口的各种错误标志位示例
__HAL_UART_CLEAR_FLAG(&huart, UART_FLAG_PE); // 清除奇偶校验错误标志
__HAL_UART_CLEAR_FLAG(&huart, UART_FLAG_FE); // 清除帧错误标志
__HAL_UART_CLEAR_FLAG(&huart, UART_FLAG_NE); // 清除噪声错误标志
__HAL_UART_CLEAR_FLAG(&huart, UART_FLAG_ORE); // 清除溢出错误标志
```
4. 软件触发中断（HAL库）
```c
/**
  * @brief  EXTI line0 回调函数.
  * @note   在STM32CubeMX生成的代码中，中断服务函数已由HAL库处理，
  *         用户主要重写此回调函数。
  */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  if (GPIO_Pin == GPIO_PIN_0)
  {
    // 处理软件中断触发的事件
    HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
  }
  // 注意：在HAL库中，中断标志位通常在HAL_GPIO_EXTI_IRQHandler中自动清除
}

// 在需要触发中断的地方，依然可以使用：
EXTI->SWIER |= EXTI_Line0;
```

# 定时器
## 定时器类型 型号（F103C8T6 为例） 核心特点 典型应用
1. 高级定时器 *TIM1* 支持 PWM 互补输出、死区控制，带刹车功能 电机驱动（需要互补 PWM）
2. 通用定时器 *TIM2、TIM3、TIM4、TIM5* 支持定时中断、PWM 输出、输入捕获，16 位计数器 精准定时、普通 PWM 控制（LED 调光、风扇调速）
3. 基本定时器 *TIM6、TIM7* 仅支持定时中断，无 PWM / 捕获功能 简单定时（如触发 ADC 转换）
## 通用定时器（以 TIM3 为例）的核心参数：
### Slave Mode
允许一个定时器（从定时器）的运行状态被另一个定时器（主定时器）或特定的外部信号所控制，从而实现精确的同步、测量或复杂的定时序列。

| 从模式                                  | 核心功能                                   | 典型应用场景                     |
| ------------------------------------ | -------------------------------------- | -------------------------- |
| **复位模式 (Reset Mode)**​               | 当触发信号到来时，计数器**立即清零**并重新开始计数。           | 频率测量、脉冲周期测量                |
| **门控模式 (Gated Mode)**​               | 触发信号为**高电平**时计数器运行，为**低电平**时计数器**暂停**。 | 脉冲宽度测量、占空比测量               |
| **触发模式 (Trigger Mode)**​             | 触发信号的边沿用于**启动**计数器（但不清零）。              | 多定时器同步启动、一次性(One-Shot)脉冲生成 |
| **外部时钟模式1 (External Clock Mode 1)**​ | 将指定的触发信号**边沿**直接作为计数器的**时钟源**。         | 外部事件计数、电机转速测量（霍尔传感器）       |
### Trigger Source
1. 内部触发 (ITRx)：这是最常用的方式，用于定时器之间的同步。芯片内部有固定的连接路由，例如TIM1的触发输出(TRGO)连接至ITR0线，TIM2的连接至ITR1线，以此类推。从定时器通过选择不同的ITR线，可以指定由哪个主定时器来控制自己。
2. 外部引脚 (TIxFPx, ETR)：将定时器的输入捕获通道（TI1FP1, TI2FP2）或专用的外部触发引脚(ETR)上的信号作为触发源。这允许外部数字信号（如来自传感器的脉冲）直接控制定时器。
#### 内部触发
#### 外部触发
1. TIxFPx：来源于定时器的输入捕获通道，例如TI1FP1对应通道1。它更灵活，一个定时器通常有多个此类通道。
	ETR：是一个专用的外部触发引脚，每个定时器只有一个。
2. 电机转速测量（正交编码器）：应选择 TIxFPx。编码器输出A、B两相正交信号，需要定时器工作在编码器接口模式，该模式必须使用 TI1和 TI2输入通道，硬件自动处理方向和计数。
	精确测量PWM信号的脉宽或频率：应选择 TIxFPx。您可以利用定时器的输入捕获功能，结合从模式（如复位模式或触发模式），高效地测量高电平时间、周期等 。TIxFPx路径支持这些复杂的联动操作。
3. 对高速数字脉冲流进行精确计数：例如测量高频时钟信号或光栅尺的脉冲，应选择 ETR。其更短的信号路径意味着可以支持更高的频率，计数结果更可靠 。
4. 资源紧张时的简单事件计数：例如记录一台设备在一天内的启动次数，信号缓慢且单一，此时 ETR​ 和 TIxFPx​ 都能胜任。若 ETR引脚恰好方便布线，可优先使用它，以释放出功能更强大的 TIx通道用于其他复杂任务。
### 在"Parameter Settings"选项卡中配置：
Prescaler (分频系数): 根据你的定时器输入时钟计算（计数范围 0~65535）。
Counter Mode (计数模式)：支持向上 / 向下 / 中心对齐计数；
Counter Period (自动重装载值ARR)：根据需要设置。
auto-reload preload (自动重载预装载)： "Enable"（推荐使能，可避免运行时重载产生的异常）。

## 核心公式：定时时间 = (PSC+1) × (ARR+1) / 定时器时钟频率
PSC（预分频器）：降低定时器的计数频率。例如，时钟频率 72MHz，PSC=71，则计数频率 = 72MHz/(71+1)=1MHz（每 1μs 计数一次）；
ARR（自动重装载寄存器）：计数器的目标值。当计数器从 0 计数到 ARR 时，触发中断并重置为 0（向上计数模式）；
定时时间：计数器从 0 到 ARR 的总耗时（单位：秒）。
## 工作流程（向上计数模式）：
定时器时钟经 PSC 分频后，得到 “计数时钟”（如 1MHz，即每 1μs 跳变一次）；
计数器从 0 开始，每过 1 个计数时钟就 + 1；
当计数器的值 = ARR 时，触发 “更新中断”（通知 NVIC），同时计数器自动重置为 0，重复计数；
NVIC 响应中断，CPU 执行定时器中断服务函数（如翻转 LED、更新数据）。
## 定时器的三大核心应用：
精准定时：替代HAL_Delay实现非阻塞延时（不占用主循环）
周期性任务：如每 10ms 采集一次传感器数据、每 1 秒更新一次屏幕显示；
脉冲测量：测量外部信号的频率、占空比。

# UART/USART：异步串行通信
| 特性维度         | 异步通信 (UART模式)                                          | 同步通信 (如USART同步模式、SPI、I2C)                                     |
| ------------ | ------------------------------------------------------ | ------------------------------------------------------------- |
| **时钟信号**​    | 无专用时钟线。通信双方使用**独立的内部时钟**，依靠**预设的波特率**和**起始位/停止位**进行同步。 | 需要一条**共享的时钟信号线（CK/SCK）**。由主机（Master）产生时钟，从机（Slave）在时钟跳变沿采样数据。 |
| **硬件连接**​    | 最少只需**两根线**：数据发送线（TX）和数据接收线（RX），实现全双工。                 | 至少需要**三条线**：时钟线（SCK）、数据线（MOSI/MISO），通常是半双工或全双工，具体取决于协议。       |
| **数据帧格式**​   | 包含**起始位、数据位（5-9位）、可选的校验位和停止位（1, 1.5, 2位）**。帧格式相对固定。    | 数据帧通常**不包含起始/停止位**<br>，格式更灵活，可由连续的、由时钟同步的数据块构成。               |
| **通信效率**​    | 较低。每个数据字节都附加了起始位、停止位等额外开销。                             | 较高。没有起始/停止位的开销，数据传输更紧凑，尤其在传输大量数据时优势明显。                        |
| **复杂性与成本**​  | 硬件和协议简单，成本较低。                                          | 硬件更复杂，需要更多引脚和配置，成本相对较高。                                       |
| **可靠性**​     | 依赖双方时钟精度，长距离或高速时易受时钟漂移影响，误码率相对较高。                      | 时钟信号伴随数据，抗时钟漂移能力强，可靠性高，误码率较低。                                 |
| **典型应用/协议**​ | UART、RS-232、RS-485。用于设备调试、GPS模块、蓝牙模块等。                 | USART同步模式、SPI、I2C。用于智能卡、高速ADC、存储器、传感器网络等。                     |

# ADC和DAC
## ADC在CubeMX上的配置
### Mode(通道)
IN0～IN9（常规通道）：告诉你芯片上的哪些引脚将被配置为**模拟输入功能**，引脚图会自动显示
Temperature Sensor Channel（温度传感器通道）：勾选后，ADC可以测量芯片内部的温度。**无需连接外部引脚**。
Vrefint Channel（内部参考电压通道）：勾选后，ADC可以测量芯片内部的一个精密参考电压，常用于提高测量精度或检测电源电压。

|特性|规则通道 (Regular Channels)|注入通道 (Injected Channels)|
|---|---|---|
|**核心功能**​|常规、顺序采集多路信号|高优先级、可打断规则转换的“插队”采集|
|**DMA配置**​|**必须且推荐使用**，用于搬运多通道数据|**通常不使用DMA**，在中断中直接读取|
|**数据寄存器**​|所有通道共享**1个**规则数据寄存器(ADC_DR)|每个注入通道有**独立的**注入数据寄存器(ADC_JDRx)|
|**数据覆盖风险**​|高（多通道需DMA及时搬运）|无（结果存于各自JDR）|
|**触发源**​|软件、定时器等多种触发源|通常由特定事件（如定时器、外部信号）触发|
|**工作模式类比**​|流水线作业，按部就班|急诊通道，优先处理紧急情况|
### ADC_Settings
1. Data Alignment（数据对齐）
   是什么：ADC转换完成后，会得到一个12位的数字（比如 0xFFF）。这个数字需要存放在一个16位的寄存器里。数据对齐就是决定这个12位的数字是放在16位寄存器的右边（低12位）还是左边（高12位）。
   怎么选：永远优先选择 “*Right alignment*”（右对齐）。这样你读取到的数值就是直接的转换结果，非常直观，不易出错。
2. Scan Conversion Mode（扫描转换模式）
	是什么：当你需要循环测量多个通道时，就需要启用这个模式。
3. Continuous Conversion Mode（连续转换模式）
	是什么：决定ADC完成一轮转换后，是否立即开始下一轮。
	Disabled（禁用）：单次模式。ADC转换一轮（可能是一个通道，也可能是扫描模式下的多个通道）后就会停止，需要你再次下令（触发）才会开始下一轮。
	Enabled（启用）：连续模式。ADC会不知疲倦地一轮接一轮地转换，产生连续的数据流。适合需要实时监控的场景。
4. Discontinuous Conversion Mode（间断转换模式）
	是什么：一个高级功能，可以忽略。简单理解就是，将一轮完整的扫描转换分成几个小批次进行。对于新手，保持 “Disabled”。
### ADC_Regular_ConversionMode（常规转换模式）
1. 这是ADC最主要的工作方式，用于处理普通的、按顺序进行的采集任务。
	Enable Regular Conversions（启用常规转换）： obviously，要使用常规通道就必须勾选。
2. Number Of Conversion（转换数量）：看你在“Mode”部分选择了几个通道。
3. External Trigger Conversion Source（外部触发源）：
	是什么：告诉ADC“什么时候开始转换”。
	Regular Conversion launched by software（软件触发）：最简答的方式。就是你在代码里写一条命令（如HAL_ADC_Start(...)）来启动转换。
	其他选项（如Timer触发）：高级方式。可以让ADC的转换由一个硬件定时器自动、精确地触发，完全不需要CPU参与。这对于需要固定采样频率（如音频采集）至关重要。
4. Rank（顺序）：
	当你设置了Number Of Conversion后，下方会出现一个表格，让你为每个“Rank”指定具体的通道。
	Rank 1： 转换序列中的第一个通道。
	Rank 2： 转换序列中的第二个通道。
### ADC_Injected_ConversionMode（注入转换模式)
### WatchDog
1. 一位尽职尽责的“电压保安”。
- 它的职责：死死盯住ADC的转换结果（也就是那个*0-4095*之间的数字值）。
- 它的工作：您给这个“保安”规定一个安全电压范围（例如，下限是1000，上限是3000）。它就会时刻监视，一旦ADC转换的结果低于下限或高于上限，就意味着电压“越界”了，出现了异常情况。
- 它的反应：这时，“保安”会立刻拉响警报（*产生一个中断*），通知CPU来处理这个紧急情况。
它的核心作用是实现硬件级别的实时监控，避免CPU需要不停地在软件中去查询ADC值是否正常，既提高了效率，又增强了系统的可靠性。
```c
/* 放在main.c的合适位置，例如所有函数之外 */
uint8_t Voltage_Error_Flag = 0; // 定义一个全局变量记录错误状态

/* 重写看门狗的中断回调函数 */
void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc) {
  if (hadc->Instance == ADC1) { // 判断是哪个ADC触发的
    Voltage_Error_Flag = 1; // 设置错误标志

    // 可以立即读取当前ADC值，判断是过高还是过低
    // uint16_t bad_value = HAL_ADC_GetValue(&hadc1);

    // 执行紧急操作，例如：关闭设备、点亮报警灯、发送错误日志等
    HAL_GPIO_WritePin(ERROR_LED_GPIO_Port, ERROR_LED_Pin, GPIO_PIN_SET);
  }
}

/* 在主函数中 */
int main(void) {
  // ... CubeMX 自动生成的初始化代码 ...

  HAL_ADC_Start_IT(&hadc1); // 以中断模式启动ADC转换

  while (1) {
    // 主循环正常执行其他任务
    if (Voltage_Error_Flag == 1) {
      // 如果发生了电压错误，可以在这里进行一些处理，比如循环闪烁LED
      Voltage_Error_Flag = 0; // 处理完后清除标志
    }
    // ... 其他代码 ...
  }
}
```

# DMA
## DMA配置参数

| 配置参数                       | 核心作用             | 常见选择策略与说明                                                                                          |
| -------------------------- | ---------------- | -------------------------------------------------------------------------------------------------- |
| **传输方向**​                  | 规定数据流向           | **外设到内存**：如ADC采集、串口接收。  <br>**内存到外设**：如串口发送、DAC输出。  <br>**内存到内存**：大数据块拷贝（仅部分DMA控制器支持，如STM32的DMA2）。 |
| **地址设置**​                  | 指定数据来源和去向        | **源/目标地址**：填写具体的外设数据寄存器地址（如`&ADC1->DR`）或内存数组首地址。                                                   |
| **地址递增Increment Address​** | 决定传输后地址是否自动改变    | **外设地址Peripheral**：通常**不递增**（如ADC、UART，其数据始终写入同一寄存器）。  <br>**内存地址Memory**：通常**递增**（如数组，需要存放到连续位置）。 |
| **数据宽度**​                  | 定义单次传输的数据量       | 需保持**外设与内存的数据宽度一致**（如外设为8位，内存也选8位），否则可能需FIFO参与处理。                                                  |
| **传输模式**​                  | 控制数据传输的整体行为      | **单次模式**：传输指定数量后停止，需重新启动。  <br>**循环模式**：传输完成后自动重置参数并重新开始，适合连续数据流（如ADC持续采样）。                        |
| **触发源**​                   | 决定DMA传输的启动条件     | **软件触发**：代码控制启动，适用于存储器到存储器传输。  <br>**硬件触发**：由外设事件（如ADC转换完成、UART收到数据）自动启动，适用于外设与存储器间的传输。            |
| **FIFO模式**​                | 数据中转缓冲，处理数据宽度不匹配 | **禁用（直接模式）**：双方数据宽度必须一致。  <br>**启用**：可缓存数据，解决源和目标数据宽度不同或时序不匹配的问题（如字节数据拼凑成字）。                       |
| **优先级**​                   | 协调多个DMA通道的竞争     | 当多个DMA通道同时请求时，优先级高的先传输。可分为**软件优先级**（可配置）和**硬件优先级**（通常通道编号小的优先）。                                    |
CPU只需要初始化这个“搬运工”（配置DMA参数），告诉它“从哪里搬（源地址）”、“搬到哪里去（目标地址）”、“搬多少（数据量）”以及“什么时候开始搬（触发源）”。
## ADC和DMA
### 标准库与HAL库关键配置对比

|配置项|标准库（Standard Peripheral Library）|HAL库（Hardware Abstraction Library）|
|---|---|---|
|**时钟使能**​|`RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);`  <br>`RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);`|CubeMX图形化配置自动生成，代码中通常无需直接调用。|
|**ADC初始化结构体**​|`ADC_InitTypeDef`|`ADC_HandleTypeDef`|
|**DMA初始化结构体**​|`DMA_InitTypeDef`|`DMA_HandleTypeDef`|
|**关键配置函数**​|`ADC_Init(ADC1, &ADC_InitStructure);`  <br>`DMA_Init(DMA1_Channel1, &DMA_InitStructure);`|`HAL_ADC_Init(&hadc1);`  <br>`HAL_DMA_Init(&hdma_adc1);`|
|**启动转换函数**​|`ADC_SoftwareStartConvCmd(ADC1, ENABLE);`|`HAL_ADC_Start_DMA(&hadc1, (uint32_t*)aADCxConvertedData, BUFFER_SIZE);`|
|**数据搬运方式**​|需手动配置DMA源地址（ADC->DR）和目标地址（内存数组）。|在`HAL_ADC_Start_DMA`函数中直接指定目标数组和大小，链接在CubeMX或代码中完成。|
### HAL库代码示例
```c
// 定义存储ADC转换结果的全局数组
#define ADC_BUFFER_SIZE 2
uint32_t adc_buffer[ADC_BUFFER_SIZE];

int main(void) {
    // HAL初始化等
    ...

    // 启动ADC，通过DMA进行转换
    // 参数：ADC句柄，目标数组地址，传输数据长度（这里指总转换次数，例如2个通道 * 100次扫描）
    if (HAL_ADC_Start_DMA(&hadc1, (uint32_t*)adc_buffer, ADC_BUFFER_SIZE) != HAL_OK) {
        Error_Handler();
    }

    while (1) {
        // 主循环，此时DMA正在后台自动更新adc_buffer数组中的数据
        // 你可以直接在此处安全地使用adc_buffer[0]和adc_buffer[1]的值
        // 例如，通过串口打印：
        // printf("Ch0: %lu, Ch1: %lu\n", adc_buffer[0], adc_buffer[1]);
        // 注意：由于DMA在后台循环写入，最好在读取时暂时关闭中断或使用双缓冲区策略以避免数据竞争。
    }
}

// 可选：DMA传输完成中断回调函数（当传输完成一半或全部时会被调用）
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) {
    if (hadc->Instance == ADC1) {
        // 可以在这里处理数据，例如设置一个标志位通知主循环
    }
}
```

### 标准库代码示例
```c
#define ADC_CHANNEL_CNT 2
uint16_t ADC_ConvertedValue[ADC_CHANNEL_CNT];

void ADC1_DMA_Init(void) {
    ADC_InitTypeDef ADC_InitStructure;
    DMA_InitTypeDef DMA_InitStructure;

    // 1. 使能时钟
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);

    // 2. 配置DMA
    DMA_DeInit(DMA1_Channel1);
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&(ADC1->DR); // 外设地址为ADC数据寄存器
    DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)ADC_ConvertedValue; // 内存地址
    DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC; // 方向：外设->内存
    DMA_InitStructure.DMA_BufferSize = ADC_CHANNEL_CNT; // 传输数据量
    DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable; // 外设地址不递增
    DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable; // 内存地址递增
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord; // 外设数据宽度半字
    DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord; // 内存数据宽度半字
    DMA_InitStructure.DMA_Mode = DMA_Mode_Circular; // 循环模式
    DMA_InitStructure.DMA_Priority = DMA_Priority_High;
    DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    DMA_Init(DMA1_Channel1, &DMA_InitStructure);
    DMA_Cmd(DMA1_Channel1, ENABLE); // 使能DMA

    // 3. 配置ADC
    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
    ADC_InitStructure.ADC_ScanConvMode = ENABLE; // 扫描模式
    ADC_InitStructure.ADC_ContinuousConvMode = ENABLE; // 连续转换
    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; // 软件触发
    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
    ADC_InitStructure.ADC_NbrOfChannel = ADC_CHANNEL_CNT; // 转换通道数
    ADC_Init(ADC1, &ADC_InitStructure);

    // 4. 配置ADC通道的转换顺序和采样时间
    ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_239Cycles5);
    ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 2, ADC_SampleTime_239Cycles5);

    // 5. 使能ADC的DMA请求
    ADC_DMACmd(ADC1, ENABLE);
    // 6. 使能ADC
    ADC_Cmd(ADC1, ENABLE);
    // 7. ADC校准
    ADC_ResetCalibration(ADC1);
    while(ADC_GetResetCalibrationStatus(ADC1));
    ADC_StartCalibration(ADC1);
    while(ADC_GetCalibrationStatus(ADC1));
    // 8. 软件启动ADC转换
    ADC_SoftwareStartConvCmd(ADC1, ENABLE);
}

int main(void) {
    ADC1_DMA_Init();
    while (1) {
        // 主循环中，ADC_ConvertedValue[0]和[1]已被DMA自动更新
    }
}
```

## 总结
- [ ] 时钟是否已使能（DMA时钟及外设时钟）？
- [ ] 传输方向是否正确（外设<->内存）？
- [ ] 地址递增设置是否符合外设和内存的特性（外设通常不增，内存通常增）？
- [ ] 数据宽度是否已对齐？
- [ ] 传输模式（循环/单次）是否适合应用场景？
- [ ] 触发源选择是否正确（硬件触发/软件触发）？
- [ ] 传输数量（BufferSize）设置是否正确？
- [ ] 是否需要以及是否正确配置了中断？
# I2C
**I2C Speed Mode (I2C速度模式)**
- **Standard Mode (标准模式)**：速率最高到**100 kHz**。**这是最经典、最通用的模式**，兼容性最好，抗干扰能力强。**对于驱动OLED、大多数传感器，这是最佳选择。**
- **Fast Mode (快速模式)**：速率最高到**400 kHz**。当需要更高刷新率（如快速更新屏幕）时可选。但需注意，某些廉价模块在高速下可能不稳定。
**I2C Clock Speed (Hz) (I2C时钟速度)**
- 这是上一个“速度模式”的具体数值体现。选择“标准模式”后，这里默认是 **`100000`**​ Hz (即100kHz)。选择“快速模式”后，此处可设为 **`400000`**​ Hz。
- **如何选**：**与速度模式保持一致即可**。100kHz是标准值，400kHz是快速模式标准值。只要不超过所选模式的上限，你可以手动输入一个更慢的值以增强稳定性。
### Slave Features（从机特性）
这部分配置STM32**作为I2C通信的接收者（从机）**时的行为。**在大多数单主机系统中（如你的STM32作为唯一主机，去控制OLED、传感器等从机），这部分配置通常无需修改，保持默认。**
- **Clock No Stretch Mode (时钟无拉伸模式)**
    - **含义**：I2C协议允许从设备在处理数据时，通过拉低时钟线(SCL)来“请求”主机等待，这称为“时钟拉伸”。如果将此选项设为 **`Enabled`**，则禁止从设备使用此功能，主机将强制按照自己的节奏通信。
    - **如何选**：**务必保持 `Disabled`**。除非你非常明确你的应用场景且确保从设备不需要拉伸时钟。对于通用性，必须允许时钟拉伸。
- **Primary Address Length selection (主地址长度选择)**
    - **7-bit**：使用7位设备地址。这是**最广泛使用的标准**，几乎所有常见I2C设备（如OLED地址0x3C/0x78，MPU6050地址0x68）都采用7位地址。
    - **10-bit**：使用10位设备地址。用于需要大量设备地址的复杂系统，非常罕见。
    - **如何选**：**选择 `7-bit`**。
- **Dual Address Acknowledged (双地址应答)**
    - **含义**：允许STM32（作为从机时）响应两个不同的I2C地址。适用于需要备份或特殊寻址的复杂应用。
    - **如何选**：**保持 `Disabled`**，除非你的具体从机功能需要。
- **Primary slave address (主从机地址)**
    - **含义**：当STM32工作在**从机模式**时，它在I2C总线上的自身地址。**在主机模式下，这个地址通常无关紧要。**
    - **如何选**：保持默认值 **`0`**​ 即可。只有当你的系统中还有另一个MCU可能把STM32当作从机来访问时，才需要设置一个不冲突的地址。
- **General Call address detection (广播呼叫地址检测)**
    - **含义**：是否允许STM32（作为从机时）响应I2C的广播呼叫地址（0x00）。主机可以通过这个地址同时向总线上所有从机发送信息。
    - **如何选**：**保持 `Disabled`**。除非你明确需要用到广播呼叫功能。