# 如何和八路循迹模块通信

我打算弄三个方式（看有没有时间吧。。。）：

1. 最简单串口通信
2. 使用中断的通信
3. 使用DMA串口通信

## 最简单的轮询式的串口通信

我这边用的是***USART1***外设，所以说，我要用PA10（RXD），和PA9（TXD）。

那么我需要的驱动代码就有：

```cpp
void UART1_Msp_Init(){
	// 使能GPIOA时钟
	__HAL_RCC_GPIOA_CLK_ENABLE();
	// 使能USART1时钟
	__HAL_RCC_USART1_CLK_ENABLE();
	
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	
	// 2. 配置PA9(TX）
	GPIO_InitStruct.Pin = GPIO_PIN_9;
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; // 复用推挽输出
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; // 高速模式
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
	
	// 配置PA10(RX)
	GPIO_InitStruct.Pin = GPIO_PIN_10;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT; // 浮空输入模式
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
}

UART_HandleTypeDef UART1_Init(int buadRate){
	UART1_Msp_Init();
	
	UART_HandleTypeDef huart;
	
	huart.Instance = USART1; // 选择USART1
	huart.Init.BaudRate = buadRate; // 波特率
	huart.Init.WordLength = UART_WORDLENGTH_8B; // 8位数据
	huart.Init.StopBits = UART_STOPBITS_1; // 1位停止位
	huart.Init.Parity = UART_PARITY_NONE; // 无校验位
	huart.Init.Mode = UART_MODE_TX_RX; // 收发模式
	huart.Init.HwFlowCtl = UART_HWCONTROL_NONE; // 无硬件流控
	huart.Init.OverSampling = UART_OVERSAMPLING_16; // 16倍过采样
	
	HAL_UART_Init(&huart); // 应用配置
	
	return huart;
}
```

wait，这样好像无法获取不定长的数据，你必须要指定数组长度！！！，我先试试看。

## 如何处理获取到的信息

我一开始打算用`sscanf()`，如下

```cpp
int x1, x2, x3, x4, x5, x6, x7, x8;
char *s = "$D,x1:0,x2:0,x3:0,x4:0,x5:0,x6:0,x7:0,x8:0#"; // 数组总长是43字节

sscanf(s, "$D,x1:%d,x2:%d,x3:%d,x4:%d,x5:%d,x6:%d,x7:%d,x8:%d#", &x1, &x2, &x3, &x4, &x5, &x6, &x7, &x8);
```

但是，后面我又想，为什么我一定要用sscanf呢？我都知道数据在哪一位了，我还有必要自己去弄吗？，所以我又想了一种更快的方式，毕竟用sscanf还是比较慢。

第一个数字的index是6，对吧？第二个是11，那么以此类推，是一个等差数列，d为5，所以。。。可以方便的弄一个数组来保存数据。

我这里要先解释一下什么是**T8**，***就是八路循迹模块的缩写***。然后**xs**，***xs就是八个红外传感的状态***。

***xs[0]就是x1的状体***，***xs[1]就是x2的状体***，以此类推。

```cpp
char *s = "$D,x1:0,x2:0,x3:0,x4:0,x5:0,x6:0,x7:0,x8:0#"; // 数组总长是43字节
char xs[8] = {0}; 

void T8_Update_xs(){
	size_t offset = 6;
	for (size_t index = 0;index < 8;index++){
		xs[index] = s[offset + 5*index];
	}
}
```

but。。。后面我又想。。。。如果接受到的数据不是刚好就是恰好对的数据呢？有可能数组的$会跑到数组的后半部分呢？#会跑到数组的前半部分呢？

怎么办呢？我想到了一次性先读取一个char，然后后面在进行处理！！！就像听别人讲话一样。听到$直接立正！！！然后开始读取代码～～～。

所以，最新的，鲁棒性更好的T8_Update_xs，他来了！！！

```cpp
// 这里面关于串口的函数是我自己写的驱动，具体可以我的STM32研究手记-stm32f103c8t6
char xs[8] = "00000000";

UART_HandleTypeDef huart1;

UART_HandleTypeDef *T8_HUART = &huart1;

void main(){
	// your code ...
	huart1 = UART1_Init(115200);
	// your code ...
}

void T8_Init(){
	HAL_Delay(20);   // 等待八路循迹模块初始化完成
	UART_print(T8_HUART, "$0,0,1#");
}

void T8_Stop(){
	UART_print(T8_HUART, "$0,0,0#");
}

void T8_Update_xs(){
	char _c; // 防止和别的变量名冲突
	while (1){
		_c = UART_readChar(T8_HUART);
		if (_c != '$') {
			continue;
		}
		_c = UART_readChar(T8_HUART);
		if (_c != 'D') {
			continue;
		}else {
			break;
		}
 	}
 	for (int i = 0;i < 8;i++){
	 	UART_discard(T8_HUART, 4);
	 	xs[i] = UART_readChar(T8_HUART);
 	}
}
```

YES，经过我的测试，也是成功读取数据，并且通过蓝牙通信了～～～～。

后面，经过我的实验

我发现

**0代表在黑线上，指示灯会亮起**， **1代表在白色上，指示灯会熄灭**

## 参考资料

1. [[1-stm32f103c8t6♥️/通信/USART通信/main]]
2. [[1-stm32f103c8t6♥️/通信/USART通信/可移植代码]]
3. 【【keysking的STM32教程】 第8集 STM32的串口通信】 https://www.bilibili.com/video/BV1Na4y1T7VQ/?share_source=copy_web&vd_source=d8165ccc8db4f797937e2198122cfca4
