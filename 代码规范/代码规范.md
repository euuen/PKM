# 代码规范

## 基本编码习惯

### 1. 保持Tab缩进的好习惯

#错误❌例子
```c
int main(){
printf("hello world")；
}
```

#正确✅例子
```c
int main(){
	printf("hello world");
}
```

### 2. 变量命名请用名词并且第一个字母请小写，并采用驼峰命名法

#错误❌例子 
```c
int Number;
int student_number;
int posItioN;
```

#正确✅例子 
```c
int number;
int studentNumber;
int postion;
```

### 3. 函数命名请用动词并且第一个字母小写，并采用驼峰命名法

#错误❌例子 
```c
int Add(int a, int b){
	return a + b;
}

void book(Book book){
	book.setPrice(114);
}
```

#正确✅例子 
```c
int add(int a, int b){
	return a + b;
}

void resetPrice(Book book){
	book.setPrice(114);
}
```

### 4. 类的命名请用名词并且第一个字母大写，并采用驼峰命名法

#错误❌例子
```cpp
class student{
public:
	std::string name;
	std::string age;
}

class add{
public:
	int add(int a, int b);
}
```

#正确✅例子 
```cpp
class Student{
public:
	Student();
	std::string name;
	std::string age;
}

class Adder{
public:
	Adder();
	int add(int a, int b);
}
```

### 5. 不管是什么命名请都让名字名副其实

### 6. 不要用小众英语单词和拼音命名

## 架构标准规范

### 1. 一个程序必须要且只要有一个Application对象

Application类，是编码规范里面最基础最重要的类。你应该继承这个类然后实现下面的方法。

1. `start()`
2. `stop()`
3. `getInstance()`

我说的initialize和clear不同于类的构造函数和解构函数，实际上他们是不同的东西，尽管有些类似。

`start()`负责初始化代码，然后启动程序主要核心代码，应该是一个大循环。

`stop()`负责终止程序执行，它应该首先把全部资源释放，然后调用`exit(0)`退出

`getInstance()`负责返回此程序的实例，这也就是为什么说整个程序为什么只能有一个Application对象的原因，因为Application是一个单例模式。

下面是一个运用了Application的例子

```java
public class Minecraft{
	public static Minecraft instance;
	
	private int a = 0;
	
	public static Minecraft getInstance(){
		return instance;
	}
	
	public Minecraft(){
		instance = this;
	}

	public void start(){
		System.out.println("初始化Minecraft");
		while (ture){
			// 大循环
			if (a > 10){
				System.out.println("去初始化Minecraft");
				stop();
			}
			a++;
		}
	}
	
	public void stop(){
		// 在这里释放资源
		System.exit(0);
	}
	
	public static void main(String args[]){
		Minecraft minecraft = new Minecraft();
		minecraft.start();
	}
}
```

### 2. 用Manager拆分Application，让Manager形成一个功能模块

比如你的程序有两个功能板块，那么你应该把他拆分成两个Manager，已达到代码拆分的目的。代码拆分的越规范，代码就越容易读懂。

Manager是一个抽象类，你应该根据需要继承他然后实现下面的方法：

1. `initialize()`
2. `update()`
3. `deinitialize()`
4. `isEnabled()`
5. `enable()`
6. `disable()`
7. `getUpdateInterval()`

`initialize()`、`deinitialize()`，虽然和构造和析构函数差不多，但是和Application类似，他们完全不是一个概念。

Application采用异步架构，使得每个Manager可以以不同的速度进行update，所以Application需要在每次更新完Manager后，调用`getUpdateInterval`来确定下次更新的时间（函数返回的单位是ms）。如果你没有实现这个函数，抽象类默认的实现是返回`33`。

如果你想暂时停用Manager，你应该实现`disable`通知Application停用Manager，当然这个停用逻辑也应该你自己写。如果想再次启用，请用`enable`通知Application。

比如现在有两个模块，一个是程序运行逻辑，一个是界面渲染逻辑。那么应该拆分成两个Manager。

这里以Minecraft举例，你应该需要一个MinecraftManager类和RenderManager类。（假设这里的Minecraft是客户端，只有客户端才有渲染逻辑的）那么，应该这么写。

```java
class MinecraftManager extends Manager {
	RenderManager renderManager;

	public MinecraftManager(){
		// 初始化资源
	}
	
	@Override
	public void intialize(){
		renderManager = Minecraft.instance.renderManager;		
	}
	
	@Override
	public void update(){
		// 使用renderManager进行渲染
	}
	
	@Override
	public void deintialize(){
		// 释放资源
	}
}

class RenderManager extends Manager {
	private ArrayList<Renderable> objects = new ArrayList<>();
	public RenderManager(){
		// 初始化窗口资源
	}
	
	@Override
	public void initialize(){
		
	}

	@Override
	public void update(){
		// 根据Renderable更新窗口
	}
	
	@Override
	public void deintialize(){
		
	}
	
	public void Render(Renderable object){
		objecsts.add(object);
	}
}

class Minecraft extends Application {
	public MinecraftManager minecraftManager;
	public RenderManager renderManager;
	
	public Minecraft(){
		minecraftManager = new MinecraftManager();
		renderManager = new RenderManager();
	}
	
	@Override
	public void intialize(){
		minecraftManager.intialize();
		renderManager.intialize();
	}
	
	@Override
	public void start(){
		// 这里为了方便演示就没有采用异步代码了，实际上这里应该是异步更新的
		while (ture){
			minecraftManager.update();
			renderManger.update();
		}
	}
	
	@Override
	public void stop(){
		minecraftManager.deinitialize();
		renderManager.deintialize();
	}
}
```

### 3. 不用更新的Manager不叫Manager，叫工具类

比如`Logger`，日志管理工具，这个不需要被更新，难道你要起一个`LogManager`么？？如果你要加Manager则说明你这个类是一定需要更新的。对于这方面的功能，我们应该封装到工具类中，比如说`Logger`，无论你怎么取名字，请一定不要加`Manager`后缀。

### 4. 在Manger的initialize方法中获取需要的Manager的实例

构造函数不应该是获取Manager的地方，因为在构造Manager的时候，所需的Manager可能还是`NullPointer`。只有带`intialize`中，全部的`Manager`才初始化了。

### 5. 在initialize方法中初始化资源，deinitialize方法中去初始化资源

不要再构造函数和析构函数中初始化和去初始化资源。此时那么有人就会问了，那构造函数和析构函数还有什么作用？？？好吧，确实没什么作用。我觉得他们最有用的功能应该就是创建一个实例对象了。

你看，在面向对象中，我们析构完一个对象后，我们还能创建一个新的对象在原来的内存地址上吗？不能。但是，如果，我们把这些代码移植到init和deinit中，就可以了。这就可以不需要全局更新挂有此对象的引用了！！！

### 6. 对解决模块间循环依赖的核心代码

```java
class AudioManager extends Manager{
	PhysicsManager physicsManager;
	
	@Override
	public void initialize(){
		physicsManager = Application.instance.physicsManager;
	}
}

class PhysicsManager extends Manager{
	AudioManager audioManager;
	
	@Override
	public void intialize(){
		audioManager = Applicaiton.instance.audioManager;
	}
}

public class Application{
	public static Application instance;
	
	PhysicsManager physicsManager;
	AudioManager audioManager;
	
	public Application() {
		instance = this;
		physicsManager = new PhysicsManager();
		audioManager = new AudioManager();
	}


	public void start(){
		physicsManager.intialize();
		audioManager.intialize();
	}
}
```

## 对遵循以上规范的代码进行模块单元测试

### 1. 测试工具类

工具类因为处于底层，不依赖任何模块，所以测试起来很简单，只要一个输入就有输出了。比较简单。比如你写了个四元数类，你只需要给他传入几个值，然后测试输出是否正确就OK了。比较简单，这里不再赘述。

### 2. 测试不依赖于其他Manager的Manager

测试这种Manager，其实和测试工具类差不多。其实就是相当于同时在测试好几个几个工具类。比较简单，这里也不再赘述。

### 3. 测试依赖于其他Manager的Manager

假设你要测试`PlayerManager`，但是此`Manager`依赖`NetworkManager`。他们二者之间的联系是，`PlayerManager`需要每次在更新世界数据的时候通过`NetworkManager`发送给其他服务器。当然这里是为了方便举例就只说了一个`NetworkManager`。

`PlayerManager`会调用`NetworkManager`的`transmitPlayerData`方法。

那么，你应该弄一个`FakeApplication`容器来运行他们，同时，你想，如果因为要用`NetworkManager`而要载入`NetworkManager`所依赖的`Manager`的话，那么只测试`PlayerManager`的意义在哪里？所以，你需要弄一个`FakeNetworkManager`，就是继承原先的`NetworkManager`，但覆写`initialize`和`transmitPlayerData`方法。

如下：

```java 
class PlayerManager extends Manager {
	NetworkManager networkManager;
	PlayerState playerstate;
	
	@Override
	public void intialize(){
		networkManager = FakeApplication.instance.networkManager;
		playerstate = new PlayerState();
	}
	
	@Override
	public void update(){
		// other code...
		transmitPlayerData(playerState);
		// other code...
	}
}

class FakeNetworkManager extends NetworkManager{
	PlayerManager playerManager;
	
	@Override
	public void intialize(){
		playerManager = FakeApplication.instance.playerManager;
	}
	
	@Override
	public void transmitPlayerData(PlayerState playerState){
		// 测试PlayerState是否符合预期
	}
}

public class FakeApplication {
	public static FakeApplication instance;
	
	public PlayerManager playerManager;
	public NetworkManager networkManager;
	
	public FakeApplication() {
		instance = this;
		playerManager = new PlayerManager();
		networkManager = new FakeNetworkManager();	
	}
	
	public void start(){
		playerManager.initialize();
		networkManager.initialize();
		
		// 对playerManager进行相关操作
		playerManager.update();
		// 测试输出是否符合预期
	}	
}
```